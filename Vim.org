#+TITLE: @pablobfonseca's VIM Configuration
#+PROPERTY: header-args:vimrc :tangle ./vim/vimrc :mkdirp yes

* Welcome to my Vim config
This file generates both [[file:vimrc][vimrc]] and [[file:vim/init.lua][init.lua]] files which can be loaded by VIM at startup.
#+begin_src vimrc
"
"        _
" __   _(_)_ __ ___
" \ \ / / | '_ ` _ \
"  \ V /| | | | | | |
"   \_/ |_|_| |_| |_|
"
" File: vimrc
" Author: Pablo Fonseca <pablofonseca777@gmail.com>
" Description: VIM Rocks!
" Source: http://github.com/pablobfonseca/dotfiles
#+end_src

#+begin_src lua
--[[
        _
 __   _(_)_ __ ___
 \ \ / / | '_ ` _ \
  \ V /| | | | | | |
   \_/ |_|_| |_| |_|

 File: init.lua
 Author: Pablo Fonseca <pablofonseca777@gmail.com>
 Description: VIM Rocks!
 Source: http://github.com/pablobfonseca/dotfiles
--]]
#+end_src

* Setup
#+begin_src vimrc
  let mapleader=","
  let maplocalleader="-"

  filetype off
  filetype plugin indent on

  autocmd!
  set nocompatible
#+end_src
** Lua Aliases
#+begin_src lua
  local cmd = vim.cmd -- to execute Vim commands e.g. cmd('pwd')
  local fn = vim.fn -- to call Vim functions e.g. fn.bufnr()
  local g = vim.g -- a table to access global variables
  local opt = vim.opt -- to set options
#+end_src

#+begin_src lua
g.mapleader = ","
g.maplocalleader = "-"

cmd 'filetype off'
cmd 'filetype plugin indent on'

cmd 'autocmd!'
opt.compatible = false
#+end_src

** Lua mapping helper function
The ~vim.api.nvim_set_keymap()~ function allows you to define a new mapping. Specific behaviors such as ~noremap~ must be passed as a table to that function. Here is a helper to create mappings with the ~noremap~ option set to true by default:

#+begin_src lua
  local function map(mode, lhs, rhs, opts)
     local options = {noremap = true}
     if opts then options = vim.tbl_extend('force', options, opts) end
     vim.api.nvim_set_keymap(mode, lhs, rhs, options)
  end

  local function t(str)
     return vim.api.nvim_replace_termcodes(str, true, true, true)
  end

  function _G.smart_enter()
     if vim.fn.pumvisible() == 1 then
        return vim.fn['coc#select_confirm']()
     else
        return t'<C-g>u'
     end
  end

#+end_src

** Source Config Files
The ~SourceConfigFilesIn~ function takes a directory and eval the files inside that directory
#+begin_src vimrc
function! s:SourceConfigFilesIn(directory)
  let directory_splat = '~/.vim/' . a:directory . '/*'
  for config_file in split(glob(directory_splat), '\n')
    if filereadable(config_file)
      execute 'source' config_file
    endif
  endfor
endfunction
#+end_src
** Plugin Setup

Setup Plug to manage my plugins

Plugins are each listed in their own file. Loop and source them using the ~SourceConfigFilesIn~
#+begin_src vimrc
call plug#begin('~/.vim/plugged')

call s:SourceConfigFilesIn('rcplugins')

call plug#end()
#+end_src

*** paq-nvim
Install the package
#+begin_src shell :tangle no
git clone --depth=1 https://github.com/savq/paq-nvim.git \
    "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/pack/paqs/start/paq-nvim
#+end_src
*** plugins
#+begin_src lua
cmd 'packadd paq-nvim' -- load the package manager
local paq = require('paq-nvim').paq -- a convenient alias

--paq {'savq/paq-nvim', opt = true} -- paq-nvim manages itself
--paq {'shougo/deoplete-lsp'}
--paq {'shougo/deoplete.nvim', run = fn['remote#host#UpdateRemotePlugins']}
--paq {'nvim-treesitter/nvim-treesitter'}
--paq {'neovim/nvim-lspconfig'}
--paq {'ojroques/nvim-lspfuzzy'}
--paq {'nvim-lua/popup.nvim'}
--paq {'nvim-lua/plenary.nvim'}
--paq {'nvim-telescope/telescope.nvim'}
--paq {'nvim-treesitter/nvim-treesitter', run = fn[':TSUpdate']}
--paq {'nvim-telescope/telescope-fzf-native.nvim', run = fn['make']}
--paq {'kyazdani42/nvim-web-devicons'}
--paq {'lewis6991/gitsigns.nvim'}
--g['deoplete#enable_at_startup'] = 1 -- enable deoplete at startup

#+end_src
* rcfiles
Vimrc is split accross multiple files, so loop over and source each

#+begin_src vimrc
call s:SourceConfigFilesIn('rcfiles')
#+end_src

** background-command
#+begin_src vimrc :tangle ./vim/rcfiles/background-command

" This callback will be executed when the entire command is completed
function! BackgroundCommandClose(channel)
  " Read the output from the command into the quickfix window
  execute "cfile! " . g:backgroundCommandOutput
  " Open the quickfix window
  copen
  unlet g:backgroundCommandOutput
endfunction

function! RunBackgroundCommand(command)
  " Make sure we're running VIM version 8 or higher.
  if v:version < 800
    echoerr 'RunBackgroundCommand requires VIM version 8 or higher'
    return
  endif

  if exists('g:backgroundCommandOutput')
    echo 'Already running task in background'
  else
    echo 'Running task in background'
    " Launch the job.
    " Notice that we're only capturing out, and not err here. This is because, for some reason, the callback
    " will not actually get hit if we write err out to the same file. Not sure if I'm doing this wrong or?
    let g:backgroundCommandOutput = tempname()
    call job_start(a:command, {'close_cb': 'BackgroundCommandClose', 'out_io': 'file', 'out_name': g:backgroundCommandOutput})
  endif
endfunction

" So we can use :BackgroundCommand to call our function.
command! -nargs=+ -complete=shellcmd RunBackgroundCommand call RunBackgroundCommand(<q-args>)

nnoremap <leader>bc :RunBackgroundCommand

" vim: ft=vim
#+end_src

** chrome
#+begin_src vimrc :tangle ./vim/rcfiles/chrome

" Chrome Cli bindings
function! s:HasFile()
  return expand("%") != ""
endfunction

function! s:OpenTab(reload, detached)
  let open_tab_command = "open-tab"
  if s:HasFile()
    update
  endif

  if a:reload
    let open_tab_command .= " --reload"
  endif

  if a:detached
    let open_tab_command .= " --detached"
  endif

  if exists("g:app_url")
    let open_tab_command .= " " . g:app_url
  endif
  call system(open_tab_command)
endfunction

command! OpenAndReloadTab call <sid>OpenTab(1, 0)
command! OpenTab call <sid>OpenTab(0, 0)
command! OpenTabDetached call <sid>OpenTab(0, 1)
nnoremap gl <silent> :OpenAndReloadTab<cr>
nnoremap gL <silent> :OpenTabDetached<cr>

nnoremap <leader>gr :!chrome-cli reload<cr><cr>
" vim: ft=vim
#+end_src
** command line
#+begin_src vimrc :tangle ./vim/rcfiles/command-line
cnoremap <C-k> <up>
cnoremap <C-j> <down>

cnoremap <C-x><C-e> <C-e><C-f>

cnoremap %% <C-R>=expand('%:h').'/'<cr>

" vim:ft=vim
#+end_src


#+begin_src lua
map('c', '<C-k>', '<up>')
map('c', '<C-j>', '<down>')

map('c', '<C-x><C-e>', '<C-e><C-f>')
map('c', '%%', '<C-R>=expand("%:h")."/"<cr>')
#+end_src
** folding
#+begin_src vimrc :tangle ./vim/rcfiles/folding

"Enable indent folding
set foldenable
set foldmethod=indent
set foldlevel=999

" Quick fold to level 1, especially useful for Coffeescript class files
nmap <leader>fld :set foldlevel=1<cr>

"Maps for folding, unfolding all
nnoremap <leader>fu zM<CR>
nnoremap <leader>uf zR<CR>

"Maps for setting foldleve
nnoremap <leader>fl1 :set foldlevel=1<cr>
nnoremap <leader>fl2 :set foldlevel=2<cr>
nnoremap <leader>fl3 :set foldlevel=3<cr>
nnoremap <leader>fl4 :set foldlevel=4<cr>

" Focus the current fold by closing all others
nnoremap <leader>flf mzzM`zzv

" Set foldlevel to match current line
nnoremap <leader>flc :execute 'set foldlevel=' . foldlevel('.')<cr>

" vim:ft=vim
#+end_src

#+begin_src lua

-- Enable indent folding
opt.foldenable = true
opt.foldmethod = 'indent'
opt.foldlevel = 999

-- Quick fold to level 1, especially useful for Coffeescript class files
map('n', '<leader>fld', '<cmd>set foldlevel=1<cr>')

-- Maps for folding, unfolding all
map('n', '<leader>fu', 'zM<CR>')
map('n', '<leader>uf', 'zR<CR>')

-- Maps for setting foldleve
map('n', '<leader>fl1', '<cmd>set foldlevel=1<cr>')
map('n', '<leader>fl2', '<cmd>set foldlevel=2<cr>')
map('n', '<leader>fl3', '<cmd>set foldlevel=3<cr>')
map('n', '<leader>fl4', '<cmd>set foldlevel=4<cr>')

-- Focus the current fold by closing all others
map('n', '<leader>flf', 'mzzM`zzv')

-- Set foldlevel to match current line
map('n', '<leader>flc', '<cmd>execute "set foldlevel=" . foldlevel(".")<cr>')
#+end_src

** functional
Functional vimscript helpers
Taken from [[ http://learnvimscriptthehardway.stevelosh.com/chapters/39.html][here]]

#+begin_src vimrc :tangle ./vim/rcfiles/functional

  function! Sorted(l)
      let new_list = deepcopy(a:l)
      call sort(new_list)
      return new_list
  endfunction

  function! Reversed(l)
      let new_list = deepcopy(a:l)
      call reverse(new_list)
      return new_list
  endfunction

  function! Append(l, val)
      let new_list = deepcopy(a:l)
      call add(new_list, a:val)
      return new_list
  endfunction

  function! Assoc(l, i, val)
      let new_list = deepcopy(a:l)
      let new_list[a:i] = a:val
      return new_list
  endfunction

  function! Pop(l, i)
      let new_list = deepcopy(a:l)
      call remove(new_list, a:i)
      return new_list
  endfunction

  function! Mapped(list, fn)
      let new_list = deepcopy(a:list)
      let FuncRef = function(a:fn)
      call map(new_list, string(FuncRef) . '(v:val)')
      return new_list
  endfunction

  function! NewFZFWindow() abort
    new | wincmd J | resize 1
  endfunction

  " Creates a floating window with a most recent buffer to be used
  function! CreateCenteredFloatingWindow()
    if has('nvim')
      let width = float2nr(&columns * 0.8)
      let height = float2nr(&lines * 0.8)
      let top = ((&lines - height) / 2) - 1
      let left = (&columns - width) / 2
      let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

      let top = '╭' . repeat('─', width - 2) . '╮'
      let mid = '│' . repeat(' ', width - 2) . '│'
      let bot = '╰' . repeat('─', width - 2) . '╯'
      let lines = [top] + repeat([mid], height - 2) + [bot]
      let s:buf = nvim_create_buf(v:false, v:true)
      call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
      call nvim_open_win(s:buf, v:true, opts)
      set winhl=Normal:Floating
      let opts.row += 1
      let opts.height -= 2
      let opts.col += 2
      let opts.width -= 4
      call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
      autocmd BufWipeout <buffer> call CleanupBuffer(s:buf)
      tnoremap <buffer> <silent> <Esc> <C-\><C-n><CR>:call DeleteUnlistedBuffers()<CR>
    endif
  endfunction

  function! OnTermExit(job_id, code, event) dict
    if has('nvim')
      if a:code == 0
        call DeleteUnlistedBuffers()
      endif
    endif
  endfunction

  function! DeleteUnlistedBuffers()
    if has('nvim')
      for n in nvim_list_bufs()
        if ! buflisted(n)
          let name = bufname(n)
          if name == '[Scratch]' ||
                \ matchend(name, ':bash') ||
                \ matchend(name, ':zsh')
            call CleanupBuffer(n)
          endif
        endif
      endfor
    endif
  endfunction

  function! CleanupBuffer(buf)
    if has('nvim')
      if bufexists(a:buf)
        silent execute 'bwipeout! '.a:buf
      endif
    endif
  endfunction

  function! ToggleTerm(cmd)
    if has('nvim')
      if empty(bufname(a:cmd))
        call CreateCenteredFloatingWindow()
        call termopen(a:cmd, { 'on_exit': function('OnTermExit') })
      else
        call DeleteUnlistedBuffers()
      endif
    endif
  endfunction

  function! ToggleScratchTerm()
    if has('nvim')
      call ToggleTerm('zsh')
    endif
  endfunction
  command! ToggleScratchTerm call ToggleScratchTerm()

  " When term starts, auto go into insert mode
  if has('nvim')
    autocmd TermOpen * startinsert

    " Turn off line numbers etc
    autocmd TermOpen * setlocal listchars= nonumber norelativenumber
  endif

  " Remove current file - Extracted from tpope's vim-eunuch plugin
  command! -bar -bang Remove
        \ let s:file = fnamemodify(bufname(<q-args>),':p') |
        \ execute 'bdelete<bang>' |
        \ if !bufloaded(s:file) && delete(s:file) |
        \   echoerr 'Failed to delete "'.s:file.'"' |
        \ endif |
        \ unlet s:file

  " Create new plugin file
  function! s:NewPlugin()
    echohl String | let text = input('Plugin name: ') | echohl None
    if text ==# '' | return | endif
    execute 'e ~/.vim/rcplugins/' . text
    execute 'set filetype=vim'
  endfunction
  command! NewPlugin call <sid>NewPlugin()
  "
  " Create new vim file
  function! s:NewVimFile()
    echohl String | let text = input('File name: ') | echohl None
    if text ==# '' | return | endif
    execute 'e ~/.vim/rcfiles/' . text
    execute 'set filetype=vim'
  endfunction
  command! NewVimFile call <sid>NewVimFile()

  " Handles closing in cases where you would be the last window
  function! CloseWindowOnSuccess(code) abort
    if a:code == 0
      let current_window = winnr()
      bdelete!
      " Handles special cases where window remains due startify
      if winnr() == current_window
        close
      endif
    endif
  endfunction

  " Open autoclosing terminal, with optional size and dir
  function! OpenTerm(cmd) abort
    if has('nvim')
      call termopen(a:cmd, {'on_exit': { _, c -> CloseWindowOnSuccess(c) }})
    else
      call term_start(a:cmd, {'exit_cb': {_, c -> CloseWindowOnSuccess(c)}})
    endif
    setf openterm
  endfunction

  " Open vsplit with animation
  function! OpenVTerm(cmd, percent) abort
    if has('nvim')
      vnew
    endif
    call OpenTerm(a:cmd)
    wincmd L | vertical resize 1
    call animate#window_percent_width(a:percent)
  endfunction

  function! OpenHTerm(cmd, percent) abort
    if has('nvim')
      new
    endif
    call OpenTerm(a:cmd)
    wincmd J | resize 1
    call animate#window_percent_height(a:percent)
  endfunction

  " vim:ft=vim

#+end_src

** functional (lua config)
#+begin_src lua

    -- Creates a floating window with a most recent buffer to be used
  vim.api.nvim_exec([[
    function! CreateCenteredFloatingWindow()
      if has('nvim')
        let width = float2nr(&columns * 0.8)
        let height = float2nr(&lines * 0.8)
        let top = ((&lines - height) / 2) - 1
        let left = (&columns - width) / 2
        let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

        let top = '╭' . repeat('─', width - 2) . '╮'
        let mid = '│' . repeat(' ', width - 2) . '│'
        let bot = '╰' . repeat('─', width - 2) . '╯'
        let lines = [top] + repeat([mid], height - 2) + [bot]
        let s:buf = nvim_create_buf(v:false, v:true)
        call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
        call nvim_open_win(s:buf, v:true, opts)
        set winhl=Normal:Floating
        let opts.row += 1
        let opts.height -= 2
        let opts.col += 2
        let opts.width -= 4
        call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
        autocmd BufWipeout <buffer> call CleanupBuffer(s:buf)
        tnoremap <buffer> <silent> <Esc> <C-\><C-n><CR>:call DeleteUnlistedBuffers()<CR>
      endif
    endfunction

    function! OnTermExit(job_id, code, event) dict
      if has('nvim')
        if a:code == 0
          call DeleteUnlistedBuffers()
        endif
      endif
    endfunction

    function! DeleteUnlistedBuffers()
      if has('nvim')
        for n in nvim_list_bufs()
          if ! buflisted(n)
            let name = bufname(n)
            if name == '[Scratch]' ||
                  \ matchend(name, ':bash') ||
                  \ matchend(name, ':zsh')
              call CleanupBuffer(n)
            endif
          endif
        endfor
      endif
    endfunction

    function! CleanupBuffer(buf)
      if has('nvim')
        if bufexists(a:buf)
          silent execute 'bwipeout! '.a:buf
        endif
      endif
    endfunction

    function! ToggleTerm(cmd)
      if has('nvim')
        if empty(bufname(a:cmd))
          call CreateCenteredFloatingWindow()
          call termopen(a:cmd, { 'on_exit': function('OnTermExit') })
        else
          call DeleteUnlistedBuffers()
        endif
      endif
    endfunction

    function! ToggleScratchTerm()
      if has('nvim')
        call ToggleTerm('zsh')
      endif
    endfunction
    command! ToggleScratchTerm call ToggleScratchTerm()

    " When term starts, auto go into insert mode
    if has('nvim')
      autocmd TermOpen * startinsert

      " Turn off line numbers etc
      autocmd TermOpen * setlocal listchars= nonumber norelativenumber
    endif

    " Remove current file - Extracted from tpope's vim-eunuch plugin
    command! -bar -bang Remove
          \ let s:file = fnamemodify(bufname(<q-args>),':p') |
          \ execute 'bdelete<bang>' |
          \ if !bufloaded(s:file) && delete(s:file) |
          \   echoerr 'Failed to delete "'.s:file.'"' |
          \ endif |
          \ unlet s:file

    " Handles closing in cases where you would be the last window
    function! CloseWindowOnSuccess(code) abort
      if a:code == 0
        let current_window = winnr()
        bdelete!
        " Handles special cases where window remains due startify
        if winnr() == current_window
          close
        endif
      endif
    endfunction

    " Open autoclosing terminal, with optional size and dir
    function! OpenTerm(cmd) abort
      if has('nvim')
        call termopen(a:cmd, {'on_exit': { _, c -> CloseWindowOnSuccess(c) }})
      else
        call term_start(a:cmd, {'exit_cb': {_, c -> CloseWindowOnSuccess(c)}})
      endif
      setf openterm
    endfunction

    " Open vsplit with animation
    function! OpenVTerm(cmd, percent) abort
      if has('nvim')
        vnew
      endif
      call OpenTerm(a:cmd)
      wincmd L | vertical resize 1
      call animate#window_percent_width(a:percent)
    endfunction

    function! OpenHTerm(cmd, percent) abort
      if has('nvim')
        new
      endif
      call OpenTerm(a:cmd)
      wincmd J | resize 1
      call animate#window_percent_height(a:percent)
    endfunction
]], true)

#+end_src

** general

#+begin_src vimrc :tangle ./vim/rcfiles/general
  set hidden                        " Allow buffer change w/o saving
  set autoread                      " Load file from disk, ie for git reset
  set nocompatible                  " Not concerned with vi compatibility
  set lazyredraw                    " Don't update while executing macros
  set backspace=indent,eol,start    " Sane backspace behavior
  set history=1000                  " Remember last 1000 commands
  set scrolloff=7                   " Start scrolling when we're 7 lines away from margins
  set mouse-=a
  set expandtab                     " Convert <tab> to spaces (2 or 4)
  set tabstop=2                     " Two spaces per tab as default
  set shiftwidth=2                  " Then override with per filteype
  set softtabstop=2                 " Specific settings via autocmd
  set secure                        " Limit what modelines and autocmds can do
  set autowrite                     " Write for me when I take any action
  set autoindent
  set copyindent
  set textwidth=79
  set viminfo+=!
  set rtp+=/usr/local/opt/fzf
  set cmdheight=2
  set formatoptions-=cro             " Stop vim to keep adding comments on carriage return
  set relativenumber
  set number
  set re=1
  scriptencoding utf-16             " Allow emoji in vimrc
  set nrformats+=alpha              " Force decimal-based arithmetic
  set shortmess+=c                  " don't give |ins-completion-menu| messages
  set updatetime=300                " You will have a bad experience for diagnostic messages when it's default 4000
  set signcolumn=yes                " always show signcolumns
  set shell=/bin/zsh                " Set zsh as default shell
  set showmatch                     " jump to matches when entering regexp
  set isfname-=:
  set shortmess+=c                  " Don't pass messages to |ins-completion-menu|

  set termguicolors

  if has('nvim')
    set inccommand=nosplit " substitute with preview
  endif

  " Fix netrw buffer issue
  let g:netrw_fastbrowse = 0

  " Disable sound/visual bell on errors
  " May need additional config about audible bell
  set t_vb=

  " Set modeline to 1 to allow rcfiles to be recognized as vim files
  set modelines=1

  " I save constantly and hate swap files in my prject dirs
  set nobackup
  set nowritebackup
  set noswapfile

  " Completions
  set completeopt-=menu
  set completeopt+=menuone   " Show the completions UI even with only 1 item
  set completeopt-=longest   " Don't insert the longest common text
  set completeopt-=preview   " Hide the documentation preview window
  set completeopt+=noinsert  " Don't insert text automatically
  set completeopt-=noselect  " Highlight the first completion automatically

  " Setup nice command tab completion
  set wildmenu
  set wildmode=list:longest,full
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc

  " Persistent undo
  let undodir = expand('~/.undo-vim')
  if !isdirectory(undodir)
    call mkdir(undodir)
  endif
  set undodir=~/.undo-vim
  set undofile " Create FILE.un~ files for persistent undo

  set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.

  " (Hopefully) removes the delay when hitting esc in insert mode
  " set noesckeys " do not work on neovim
  set ttimeout
  " Don't wait so long for the next keypress (particularly in ambigious Leader
  " situations.
  set timeoutlen=500

  " vim:ft=vim

#+end_src

#+begin_src lua
  opt.hidden = true                              -- Allow buffer change w/o saving
  opt.autoread = true                            -- Load file from disk, ie for git reset
  opt.compatible = false                         -- Not concerned with vi compatibility
  opt.lazyredraw = true                          -- Don't update while executing macros
  opt.backspace = {'indent', 'eol', 'start'}     -- Sane backspace behavior
  opt.history = 1000                             -- Remember last 1000 commands
  opt.scrolloff = 7                              -- Start scrolling when we're 7 lines away from margins
  opt.mouse = ''
  opt.expandtab = true                           -- Convert <tab> to spaces (2 or 4)
  opt.tabstop = 2                                -- Two spaces per tab as default
  opt.shiftwidth = 2                             -- Then override with per filteype
  opt.softtabstop = 2                            -- Specific settings via autocmd
  opt.secure = true                              -- Limit what modelines and autocmds can do
  opt.autowrite = true                           -- Write for me when I take any action
  opt.autoindent = true
  opt.copyindent = true
  opt.textwidth = 79
  opt.rtp:append({'/usr/local/opt/fzf'})
  opt.cmdheight = 2
  opt.formatoptions:remove({'cro'})              -- Stop vim to keep adding comments on carriage return
  opt.relativenumber = true
  opt.number = true
  opt.re = 1
  opt.nrformats:append({'alpha'})                -- Force decimal-based arithmetic
  opt.shortmess:append({A = true, c = true})     -- don't give |ins-completion-menu| messages
  opt.updatetime = 300                           -- You will have a bad experience for diagnostic messages when it's default 4000
  opt.signcolumn = 'yes'                         -- always show signcolumns
  opt.shell = '/bin/zsh'                         -- Set zsh as default shell
  opt.showmatch = true                           -- jump to matches when entering regexp
  opt.isfname:remove({':'})
  opt.termguicolors = true
  opt.inccommand = 'nosplit'                     -- substitute with preview

  g.netrw_fastbrowse = 0                         -- Fix netrw buffer issue

  -- Set modeline to 1 to allow rcfiles to be recognized as vim files
  opt.modelines = 1

  -- Disable swap files
  opt.backup = false
  opt.writebackup = false
  opt.swapfile = false

  -- Completions
  opt.completeopt:append({'menuone', 'noinsert'})
  opt.completeopt:remove({'longest', 'preview', 'menu', 'noselect'})

  -- Setup nice command tab completion
  opt.wildmenu = true
  opt.wildmode= {'list:longest','full'}
  opt.wildignore:append({'*/tmp/*','*.so','*.swp','*.zip','*.pyc'})

  -- Persistent undo
  local undodir = fn.expand('~/.undo-vim')
  if not fn.isdirectory(undodir) then
     fn.mkdir(undodir)
  end

  opt.undodir = {'~/.undo-vim'}
  opt.undofile = true -- Create FILE.un~ files for persistent undo

  opt.shiftround = true -- When at 3 spaces and I hit >>, go to 4, not 5.

  -- (Hopefully) removes the delay when hitting esc in insert mode
  opt.ttimeout = true
  -- Don't wait so long for the next keypress (particularly in ambigious Leader situations.
  opt.timeoutlen = 500
#+end_src
** programming
*** copilot
#+begin_src vimrc :tangle ./vim/rcplugins/copilot
" copilot - Github copilot
Plug 'github/copilot.vim'

" vim: ft=vim
#+end_src
*** languages
**** go
#+begin_src vimrc :tangle ./vim/rcfiles/go

augroup filetype_go
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd BufNewFile,BufRead *.go setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd Filetype go nmap <leader>r :GoRun <cr><Esc>
  autocmd Filetype go nmap <leader>t <Plug>(go-test)
  autocmd Filetype go nmap <leader>c <Plug>(go-coverage-toggle)
  autocmd Filetype go nmap <leader>b :<C-u>call <SID>build_go_files()<cr>
augroup END

let g:go_fmt_command = "goimports"
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_fields = 1
let g:go_highlight_types = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand("%")
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

" vim:ft=vim

#+end_src
**** go (lua config)
#+begin_src lua
  -- Golang config

  cmd 'augroup filetype_go'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- autoindent with two spaces, always expand tabs
  cmd  'autocmd BufNewFile,BufRead *.go setlocal ai sw=4 ts=4 sts=4 et fileformat=unix'
  cmd  'autocmd Filetype go nmap <leader>r :GoRun <cr><Esc>'
  cmd  'autocmd Filetype go nmap <leader>t <Plug>(go-test)'
  cmd  'autocmd Filetype go nmap <leader>c <Plug>(go-coverage-toggle)'
  cmd  'autocmd Filetype go nmap <leader>b :<C-u>call <SID>build_go_files()<cr>'
  cmd 'augroup END'

  g.go_fmt_command = "goimports"
  g.go_highlight_functions = 1
  g.go_highlight_methods = 1
  g.go_highlight_fields = 1
  g.go_highlight_types = 1
  g.go_highlight_operators = 1
  g.go_highlight_build_constraints = 1

  -- run :GoBuild or :GoTestCompile based on the go file
  vim.api.nvim_exec(
     [[
  function! BuildGoFiles()
    let l:file = expand("%")
    if l:file =~# '^\f\+_test\.go$'
      call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
      call go#cmd#Build(0)
    endif
  endfunction]],true)

#+end_src
**** haskell
#+begin_src vimrc :tangle ./vim/rcfiles/haskell

augroup filetype_haskell
  " Clear old autocmds in group
  autocmd!
  autocmd FileType haskell nnoremap <leader>hr :Dispatch runhaskell %<tab><cr>
  autocmd FileType haskell nnoremap <leader>hb :Dispatch ghc %<tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** haskell (lua config)
#+begin_src lua
  -- Haskell config

cmd 'augroup filetype_haskell'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  cmd 'autocmd FileType haskell nnoremap <leader>hr :Dispatch runhaskell %<tab><cr>'
  cmd 'autocmd FileType haskell nnoremap <leader>hb :Dispatch ghc %<tab><cr>'
cmd 'augroup END'
#+end_src
**** html
#+begin_src vimrc :tangle ./vim/rcfiles/html

augroup filetype_html
  " Clear old autocmds in group
  autocmd!
  " Install Emmet
  autocmd FileType html,css EmmetInstall
augroup END

" vim:ft=vim

#+end_src
**** html (lua config)
#+begin_src lua
-- HTML config

cmd 'augroup filetype_html'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- Install Emmet
  cmd 'autocmd FileType html,css EmmetInstall'
cmd 'augroup END'
#+end_src
**** javascript
#+begin_src vimrc :tangle ./vim/rcfiles/javascript
" au BufRead,BufNewFile *.json set filetype=json
augroup filetype_javascript
  " Clear old autocmds in group
  autocmd!
  " Set syntax javascript to coffee script files
  autocmd FileType javascript nnoremap <leader>r :Dispatch node %<cr>
  autocmd FileType javascript.jsx set ft=javascript
augroup END

" vim:ft=vim



#+end_src
**** javascript (lua config)
#+begin_src lua
-- Javascript config

cmd 'augroup filetype_javascript'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- Set syntax javascript to coffee script files
  cmd 'autocmd FileType javascript nnoremap <leader>r :Dispatch node %<cr>'
  cmd 'autocmd FileType javascript.jsx set ft=javascript'
cmd 'augroup END'
#+end_src
**** json

#+begin_src vimrc :tangle ./vim/rcfiles/json
augroup filetype_json
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd Filetype json nmap <leader>p :w<cr> :PrettyJSON<cr> :w<cr>
augroup END

" Requires 'jq' (brew install jq)
function! s:PrettyJSON()
  %!jq .
  set filetype=json
endfunction
command! PrettyJSON :call <sid>PrettyJSON()
" vim:ft=vim

#+end_src
**** json (lua config)

#+begin_src lua
-- JSON config
  cmd 'augroup filetype_json'
    -- Clear old autocmds in group
    cmd 'autocmd!'
    -- autoindent with two spaces, always expand tabs
    cmd 'autocmd Filetype json nmap <leader>p :w<cr> :PrettyJSON<cr> :w<cr>'
  cmd 'augroup END'

  -- Requires 'jq' (brew install jq)
  vim.api.nvim_exec(
  [[
    function! PrettyJSON()
      %!jq .
      set filetype=json
    endfunction
    ]],true)
  vim.api.nvim_command('command! PrettyJSON :call PrettyJSON()')
#+end_src
**** lua
#+begin_src vimrc :tangle ./vim/rcfiles/lua

augroup filetype_lua
  " Clear old autocmds in group
  autocmd!
  autocmd FileType lua nnoremap <leader>r :Dispatch lua %<Tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** lua (lua config)
#+begin_src lua
-- Lua config

cmd 'augroup filetype_lua'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  cmd 'autocmd FileType lua nnoremap <leader>r :Dispatch lua %<Tab><cr>'
cmd 'augroup END'
#+end_src
**** markdown
#+begin_src vimrc :tangle ./vim/rcfiles/markdown
augroup filetype_markdown_and_txt
  " Clear old autocmds in group
  autocmd!
  " By default, vim thinks .md is Modula-2.
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown
  autocmd FileType pad-notes set filetype=markdown
  " Without this, vim breaks in the middle of words when wrapping
  autocmd FileType markdown setlocal nolist wrap lbr
  " Turn on spell-checking in markdown and text.
  autocmd BufRead,BufNewFile *.md,*.txt setlocal spell
  " Don't display whitespaces
  autocmd BufNewFile,BufRead *.txt setlocal nolist
augroup END

" vim: ft=vim
#+end_src
**** markdown (lua config)
#+begin_src lua
-- Markdown config

cmd 'augroup filetype_markdown_and_txt'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- By default, vim thinks .md is Modula-2.
  cmd 'autocmd BufNewFile,BufReadPost *.md set filetype=markdown'
  cmd 'autocmd FileType pad-notes set filetype=markdown'
  -- Without this, vim breaks in the middle of words when wrapping
  cmd 'autocmd FileType markdown setlocal nolist wrap lbr'
  -- Turn on spell-checking in markdown and text.
  cmd 'autocmd BufRead,BufNewFile *.md,*.txt setlocal spell'
  -- Don't display whitespaces
  cmd 'autocmd BufNewFile,BufRead *.txt setlocal nolist'
cmd 'augroup END'
#+end_src
**** python
#+begin_src vimrc :tangle ./vim/rcfiles/python

let g:python_host_prog='/usr/bin/python'
let g:python3_host_prog='/opt/homebrew/bin/python3'

augroup filetype_python
  " Clear old autocmds in group
  autocmd!
  autocmd BufNewFile,BufRead *.py setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd FileType python nnoremap <leader>py :Dispatch python3 %<Tab><cr>
  autocmd FileType python nnoremap <leader>pt :TestFile<cr>
  autocmd BufWritePre *.py :%s/\s\+$//e
augroup END
" vim:ft=vim

#+end_src
**** python (lua config)
#+begin_src lua
-- Python config

g.python_host_prog = '/usr/bin/python'
g.python3_host_prog = '/opt/homebrew/bin/python3'

cmd 'augroup filetype_python'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  cmd 'autocmd BufNewFile,BufRead *.py setlocal ai sw=4 ts=4 sts=4 et fileformat=unix'
  cmd 'autocmd FileType python nnoremap <leader>py :Dispatch python3 %<Tab><cr>'
  cmd 'autocmd FileType python nnoremap <leader>pt :TestFile<cr>'
  cmd [[autocmd BufWritePre *.py :%s/\s\+$//e]]
cmd 'augroup END'
#+end_src
**** ruby
#+begin_src vimrc :tangle ./vim/rcfiles/ruby

let g:ruby_path = system('rvm current')
let ruby_operators = 1

augroup filetype_ruby
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd FileType rspec set filetype=ruby
  autocmd FileType ruby,eruby,yaml setlocal ai sw=2 sts=2 et
  autocmd FileType ruby,eruby,yaml setlocal path+=lib
  " Make ?s part of words
  autocmd FileType ruby,eruby,yaml setlocal iskeyword+=?
  autocmd FileType gitcommit setlocal spell textwidth=72
  " Run the current ruby file
  autocmd FileType ruby nnoremap <leader>r :Dispatch ruby %<cr>
  " Generage tags for ruby files
  autocmd FileType ruby nnoremap <Leader>rt :!ctags -R --languages=ruby --exclude=.git --exclude=log .<cr>
  " Remove trailing whitespace on save for ruby files.
  autocmd BufWritePre *.rb :%s/\s\+$//e
  autocmd BufRead,BufNewFile {Vagrantfile,Gemfile,Guardfile,Thorfile,Procfile,config.ru,*.rake,.pryrc} set filetype=ruby
  " Set .erb html files
  autocmd FileType eruby setlocal sw=2 sts=2 ts=2 " Two spaces per tab

  " Setting for vim-dispatch
  autocmd FileType ruby
        \ let b:start = executable('pry') ? 'pry -r "%:p"' : 'irb -r "%:p"' |
        \ if expand('%') =~# '_spec\.rb$' |
        \   let b:dispatch = 'rspec %' |
        \ elseif expand('%') =~# '_test\.rb$' |
        \   let b:dispatch = 'ruby -Ilib:test %' |
        \ elseif !exists('b:dispatch') |
        \   let b:dispatch = 'ruby -wc %' |
        \ endif

  " Clean comments
  autocmd FileType ruby nnoremap <leader>cc :g/#/d<cr>
  nnoremap <Leader>t :w<cr>:TestFile<cr>
  nnoremap <Leader>s :TestNearest<cr>
  nnoremap <Leader>a :TestSuite<cr>
  nnoremap <Leader>l :TestLast<cr>
  nnoremap <leader>or :tabe config/routes.rb<cr>
  nnoremap <leader>ol :tabe config/locales<cr>
augroup END

" Convert 1.8 hash syntax to 1.9 syntax
nnoremap <leader>19 :%s/:\([^ ]*\)\(\s*\)=>/\1:/gc<cr>
vnoremap <leader>19 :s/:\([^ ]*\)\(\s*\)=>/\1:/g<cr>
nnoremap <leader>18 :%s/\(\w\+\):\s/:\1 => /gc<cr>
vnoremap <leader>18 :s/\(\w\+\):\s/:\1 => /g<cr>

" vim:ft=vim
#+end_src
**** ruby (lua config)
#+begin_src lua
-- Ruby config

g.ruby_path = fn.system('rvm current')
g.ruby_operators = 1

cmd 'augroup filetype_ruby'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- autoindent with two spaces, always expand tabs
  cmd 'autocmd FileType rspec set filetype=ruby'
  cmd 'autocmd FileType ruby,eruby,yaml setlocal ai sw=2 sts=2 et'
  cmd 'autocmd FileType ruby,eruby,yaml setlocal path+=lib'
  -- Make ?s part of words
  cmd 'autocmd FileType ruby,eruby,yaml setlocal iskeyword+=?'
  cmd 'autocmd FileType gitcommit setlocal spell textwidth=72'
  -- Run the current ruby file
  cmd 'autocmd FileType ruby nnoremap <leader>r :Dispatch ruby %<cr>'
  -- Generage tags for ruby files
  cmd 'autocmd FileType ruby nnoremap <Leader>rt :!ctags -R --languages=ruby --exclude=.git --exclude=log .<cr>'
  -- Remove trailing whitespace on save for ruby files.
  cmd [[autocmd BufWritePre *.rb :%s/\s\+$//e]]
  cmd 'autocmd BufRead,BufNewFile {Vagrantfile,Gemfile,Guardfile,Thorfile,Procfile,config.ru,*.rake,.pryrc} set filetype=ruby'
  -- Set .erb html files
  cmd 'autocmd FileType eruby setlocal sw=2 sts=2 ts=2' -- Two spaces per tab

  -- Setting for vim-dispatch
  cmd([[
    autocmd FileType ruby
        \ let b:start = executable('pry') ? 'pry -r "%:p"' : 'irb -r "%:p"' |
        \ if expand('%') =~# '_spec\.rb$' |
        \   let b:dispatch = 'rspec %' |
        \ elseif expand('%') =~# '_test\.rb$' |
        \   let b:dispatch = 'ruby -Ilib:test %' |
        \ elseif !exists('b:dispatch') |
        \   let b:dispatch = 'ruby -wc %' |
        \ endif
]])

  -- Clean comments
  cmd 'autocmd FileType ruby nnoremap <leader>cc :g/#/d<cr>'
  map('n', '<Leader>t', '<cmd>w<cr>:call RunTest("TestFile")<cr>')
  map('n', '<Leader>s', '<cmd>call RunTest("TestNearest")<cr>')
  map('n', '<Leader>a', '<cmd>call RunTest("TestSuite")<cr>')
  map('n', '<Leader>l', '<cmd>call RunTest("TestLast")<cr>')
  map('n', '<leader>or', '<cmd>tabe config/routes.rb<cr>')
  map('n', '<leader>ol', '<cmd>tabe config/locales<cr>')
cmd 'augroup END'
#+end_src
**** rust
#+begin_src vimrc :tangle ./vim/rcfiles/rust

augroup filetype_rust
  " Clear old autocmds in group
  autocmd!
  autocmd FileType rust nnoremap <leader>cr :Cargo run<cr>
  autocmd FileType rust nnoremap <leader>cb :Cargo build<cr>
augroup END
" vim:ft=vim
#+end_src
**** rust (lua config)
#+begin_src lua

-- Rust config

cmd 'augroup filetype_rust'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  cmd 'autocmd FileType rust nnoremap <leader>cr :Cargo run<cr>'
  cmd 'autocmd FileType rust nnoremap <leader>cb :Cargo build<cr>'
cmd 'augroup END'
#+end_src
**** sql
#+begin_src vimrc :tangle ./vim/rcfiles/sql

augroup filetype_sql
  " Clear old autocmds in group
  autocmd!

  autocmd FileType sql call SqlFormatter()
augroup END

function SqlFormatter()
  set noai

  map ,pt :%!sqlformat --reindent --keywords upper --identifiers lower -<CR>
endfunction

" vim:ft=vim
#+end_src

**** sql (lua config)
#+begin_src lua

-- SQL config

cmd 'augroup filetype_sql'
  -- Clear old autocmds in group
  cmd 'autocmd!'

  cmd 'autocmd FileType sql call SqlFormatter()'
cmd 'augroup END'

vim.api.nvim_exec([[
function SqlFormatter()
  set noai

  map ,pt :%!sqlformat --reindent --keywords upper --identifiers lower -<CR>
endfunction
]], true)
#+end_src

*** refactoring
#+begin_src vimrc :tangle ./vim/rcfiles/refactoring
" Borrowed from Gary Bernhardt's vimrc
function! ExtractVariable()
  echohl String | let name = input("Variable name: ") | echohl None
  if name == '' | return | endif

  " Enter visual mode (input() takes us out of it)
  normal! gv

  " Replace selected text with the variable name
  exec "normal c" . name
  " Define the variable on the line above
  if &ft == "vim"
    exec "normal! Olet " . name . " = "
  elseif &ft == 'javascript'
    exec "normal! Ovar " . name . " = "
  else
    exec "normal! O" . name . " = "
  endif
  " Paste the original selected text to be the variable value
  normal! $p
  if &ft == 'javascript'
    normal! A;
  endif
endfunction
vnoremap <leader>ev :call ExtractVariable()<cr>

function! InlineVariable()
  if &filetype == 'javascript'
    s/\v^(\s+)var (.*);$/\1\2/
    nohl
  elseif &filetype == 'vim'
    s/\v^(\s+)let (.*)$/\1\2/
    nohl
  endif
  normal! ^*Ndf=x"vd$ddnviw"vp
endfunction
nnoremap <leader>ve :call InlineVariable()<cr>

" vim: ft=vim
#+end_src
** helpfiles
#+begin_src vimrc :tangle ./vim/rcfiles/helpfiles

au filetype help call HelpFileMode()

function! HelpFileMode()
  wincmd T " Maximze the help on open
  nnoremap <buffer> <tab> :call search('\|.\{-}\|', 'w')<cr>:noh<cr>2l
  nnoremap <buffer> <S-tab> F\|:call search('\|.\{-}\|', 'wb')<cr>:noh<cr>2l
  nnoremap <buffer> <cr> <c-]>
  nnoremap <buffer> <bs> <c-T>
  nnoremap <buffer> q :q<CR>
  setlocal nonumber
  setlocal nospell
endfunction

nnoremap <leader>rh :h local-additions<cr>

" vim:ft=vim

#+end_src

** helpfiles (lua config)
#+begin_src lua

-- Helpfiles

cmd 'au filetype help call HelpFileMode()'

vim.api.nvim_exec([[
    function! HelpFileMode()
      wincmd T " Maximze the help on open
      nnoremap <buffer> <tab> :call search('\|.\{-}\|', 'w')<cr>:noh<cr>2l
      nnoremap <buffer> <S-tab> F\|:call search('\|.\{-}\|', 'wb')<cr>:noh<cr>2l
      nnoremap <buffer> <cr> <c-]>
      nnoremap <buffer> <bs> <c-T>
      nnoremap <buffer> q :q<CR>
      setlocal nonumber
      setlocal nospell
    endfunction
]], true)

map('n', '<leader>rh', '<cmd>h local-additions<cr>')

#+end_src

** mappings
#+begin_src vimrc :tangle ./vim/rcfiles/mappings

" Emacs-like mappings
nmap <C-x><C-s> :w<cr>
nmap <C-x><C-c> :x<cr>
nmap <C-s> /
" nmap <C-x>b :FzfBuffers<cr>
nmap <C-c>pf :FzfFiles<cr>
nmap <C-x>1 :only<cr>
nmap <C-x>2 :split<cr>
nmap <C-x>3 :vsplit<cr>
nmap <C-x>0 :q<cr>

nnoremap <silent> H :call <SID>show_documentation()<cr>

nnoremap <silent> K :lua require('spectre').open_visual({select_word=true})<CR>

function! s:show_documentation()
  if (index(['vim', 'help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

" Opens help the word under the cursor
nnoremap <leader>h :exe 'help' expand('<cword>')<cr>

" select last paste in visual mode
nnoremap gp `[v`]

" Change vertically split to horizonally
nnoremap <leader>fh <C-w>t<C-w>K

" Change horizonally split to vertically
nnoremap <leader>fv <C-w>t<C-w>H

" Make Y yank to end of line (like D, or C)
nmap Y y$

" Insert a caller into Ruby code
nnoremap <leader>wtf oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc>

" Source vimrc
nnoremap <leader>sv :source ~/.vim/vimrc<cr>

" Toggle paste mode on and off
nnoremap <leader>pp :set paste<cr>o<esc>"*]p:set nopaste<cr>

nnoremap ; :

" Indent the whole file
nnoremap <Leader>i mmgg=G`m

" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
nnoremap <space>e :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <C-x><C-f> :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <space>s :split <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>v :vsplit <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>r :r <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>t :tabe <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>sav :sav <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>

" Use j/k to start, then scroll through autocomplete options
inoremap <expr> <C-j> ((pumvisible())?("\<C-n>"):("\<C-x><c-n>"))
inoremap <expr> <C-k> ((pumvisible())?("\<C-p>"):("\<C-x><c-k>"))

" Close the quickfix window
nnoremap <space><space> :ccl<cr>

" Increase and decrease numbers
nnoremap <C-b> <C-a>

" Let's be reasonable, shall we?
nnoremap k gk
nnoremap j gj

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f')<CR>

" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace')<CR>

" Disable arrows
for prefix in ['i', 'n', 'v']
  for key in ['<Up>', '<Down>', '<Left>', '<Right>']
    exe prefix . 'noremap ' . key . " <Nop>"
  endfor
endfor

" resize panes
nnoremap <silent> <Up> :call animate#window_delta_height(15)<cr>
nnoremap <silent> <Down> :call animate#window_delta_height(-15)<cr>
nnoremap <silent> <Left> :call animate#window_delta_width(30)<cr>
nnoremap <silent> <Right> :call animate#window_delta_width(-30)<cr>

" Scroll the viewport faster
nnoremap <C-e> 7<C-e>
nnoremap <C-y> 7<C-y>
vnoremap <C-e> 7<C-e>
vnoremap <C-y> 7<C-y>

" Disable mouse scroll wheel
nnoremap <ScrollWheelUp> <nop>
nnoremap <S-ScrollWheelUp> <nop>
nnoremap <C-ScrollWheelUp> <nop>
nnoremap <ScrollWheelDown> <nop>
nnoremap <S-ScrollWheelDown> <nop>
nnoremap <C-ScrollWheelDown> <nop>
nnoremap <ScrollWheelLeft> <nop>
nnoremap <S-ScrollWheelLeft> <nop>
nnoremap <C-ScrollWheelLeft> <nop>
nnoremap <ScrollWheelRight> <nop>
nnoremap <S-ScrollWheelRight> <nop>
nnoremap <C-ScrollWheelRight> <nop>

" Open Gemfile
nnoremap <leader>og :e Gemfile<cr>

" Jump to start and end of line using the home row keys
nmap 0 ^

" Tab/shift-tab to indent/outdent in visual mode.
vnoremap <Tab> >gv
vnoremap <S-Tab> <gv

" Quickly browse to any tag/symbol in the project
nmap <leader>ot :tag<space>

" Save file as sudo
cmap w!! w !sudo tee % >/dev/null

" Move split to tab
noremap <leader>mt <c-w><s-t>

" Map to increment and decrement
nnoremap + <C-a>
nnoremap - <C-x>
xnoremap + g<C-a>
xnoremap - g<C-x>

" Open Lazygit
nnoremap <leader>tlg :call OpenHTerm('lazygit', 0.8)<cr>
" Open Lazydocker
nnoremap <leader>tld :call OpenHTerm('lazydocker', 0.8)<cr>

" Correct previous misspelled word ( Don't forgot to set spell )
nnoremap <space>sp mm[s1z=`m

"vim:ft=vim
#+end_src

** mappings (lua config)
#+begin_src lua
  -- Mappings

  -- Emacs-like mappings
  map('n', '<C-x><C-s>', '<cmd>w<cr>')
  map('n', '<C-x><C-c>', '<cmd>x<cr>')
  map('n', '<C-s>', '/')
  map('n', '<C-c>pf', '<cmd>FzfFiles<cr>')
  map('n', '<C-x>1', '<cmd>only<cr>')
  map('n', '<C-x>2', '<cmd>split<cr>')
  map('n', '<C-x>3', '<cmd>vsplit<cr>')
  map('n', '<C-x>0', '<cmd>q<cr>')

  function _G.show_documentation()
     if fn.index({'vim', 'help'}, vim.bo.filetype) >= 0 then
        vim.api.nvim_command('execute "h ".expand("<cword>")')
     else
        vim.api.nvim_command('call CocActionAsync("doHover")')
     end
  end

  map('n', 'H', 'v:lua.show_documentation()', { noremap = true, silent = true})
  map('n', 'K', '<cmd>Rg <C-R><C-W><cr>', { noremap = true, silent = true})

  -- Opens help the word under the cursor
  map('n', '<leader>h', '<cmd>exe "help" expand("<cword>")<cr>')

  -- select last paste in visual mode
  map('n', 'gp', '`[v`]')

  -- Change vertically split to horizonally
  map('n', '<leader>fh', '<C-w>t<C-w>K')

  -- Change horizonally split to vertically
  map('n', '<leader>fv', '<C-w>t<C-w>H')

  -- Make Y yank to end of line (like D, or C)
  map('n', 'Y', 'y$')

  -- Insert a caller into Ruby code
  map('n', '<leader>wtf', 'oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc>')

  -- Source vimrc
  map('n', '<leader>sv', '<cmd>source ~/.vim/init.lua<cr>')

  -- Toggle paste mode on and off
  map('n', '<leader>pp', '<cmd>set paste<cr>o<esc>"*]p:set nopaste<cr>')

  map('n', ';', ':')

  -- Indent the whole file
  map('n', '<Leader>i', 'mmgg=G`m')

  -- Edit another file in the same directory as the current file
  -- uses expression to extract path from current file's path
  map('n', '<space>e', '<cmd>e <C-R>=escape(expand("%:p:h")," ") . "/"<CR>')
  map('n', '<C-x><C-f>', '<cmd>e <C-R>=escape(expand("%:p:h")," ") . "/"<CR>')
  map('n', '<space>s', '<cmd>split <C-R>=escape(expand("%:p:h"), " ") . "/"<CR>')
  map('n', '<space>v', '<cmd>vsplit <C-R>=escape(expand("%:p:h"), " ") . "/"<CR>')
  map('n', '<space>r', '<cmd>r <C-R>=escape(expand("%:p:h"), " ") . "/"<CR>')
  map('n', '<space>t', '<cmd>tabe <C-R>=escape(expand("%:p:h"), " ") . "/"<CR>')
  map('n', '<space>sav', '<cmd>sav <C-R>=escape(expand("%:p:h"), " ") . "/"<CR>')

  -- Use j/k to start, then scroll through autocomplete options
  map('i', '<expr> <C-j>', [[((vim.fn.pumvisible())?("\<C-n>"):("\<C-x><c-n>"))]])
  map('i', '<expr> <C-k>', [[((vim.fn.pumvisible())?("\<C-p>"):("\<C-x><c-k>"))]])

  -- Close the quickfix window
  map('n', '<space><space>', '<cmd>ccl<cr>')

  -- Increase and decrease numbers
  map('n', '<C-b>', '<C-a>')

  -- Let's be reasonable, shall we?
  map('n', 'k', 'gk')
  map('n', 'j', 'gj')

  -- Visual mode pressing * or # searches for the current selection
  -- Super useful! From an idea by Michael Naumann
  map('v', '<silent> *', '<cmd>call VisualSelection("f")<CR>')

  -- When you press <leader>r you can search and replace the selected text
  map('v', '<silent> <leader>r', '<cmd>call VisualSelection("replace")<CR>')

  -- Disable arrows
  for _,prefix in pairs({ 'i', 'n', 'v' }) do
     for _,key in pairs({ '<Up>', '<Down>', '<Left>', '<Right>' }) do
        map(prefix, key, '<Nop>')
     end
  end

  -- resize panes
  map('n', '<silent> <Up>', '<cmd>call animate#window_delta_height(15)<cr>')
  map('n', '<silent> <Down>', '<cmd>call animate#window_delta_height(-15)<cr>')
  map('n', '<silent> <Left>', '<cmd>call animate#window_delta_width(30)<cr>')
  map('n', '<silent> <Right>', '<cmd>call animate#window_delta_width(-30)<cr>')

  -- Scroll the viewport faster
  map('n', '<C-e>', '7<C-e>')
  map('n', '<C-y>', '7<C-y>')
  map('v', '<C-e>', '7<C-e>')
  map('v', '<C-y>', '7<C-y>')

  -- Disable mouse scroll wheel
  map('n', '<ScrollWheelUp>', '<nop>')
  map('n', '<S-ScrollWheelUp>', '<nop>')
  map('n', '<C-ScrollWheelUp>', '<nop>')
  map('n', '<ScrollWheelDown>', '<nop>')
  map('n', '<S-ScrollWheelDown>', '<nop>')
  map('n', '<C-ScrollWheelDown>', '<nop>')
  map('n', '<ScrollWheelLeft>', '<nop>')
  map('n', '<S-ScrollWheelLeft>', '<nop>')
  map('n', '<C-ScrollWheelLeft>', '<nop>')
  map('n', '<ScrollWheelRight>', '<nop>')
  map('n', '<S-ScrollWheelRight>', '<nop>')
  map('n', '<C-ScrollWheelRight>', '<nop>')

  -- Open Gemfile
  map('n', '<leader>og', '<cmd>e Gemfile<cr>')

  -- Jump to start and end of line using the home row keys
  map('n', '0', '^')

  -- Tab/shift-tab to indent/outdent in visual mode.
  map('v', '<Tab>', '>gv')
  map('v', '<S-Tab>', '<gv')

  -- Quickly browse to any tag/symbol in the project
  map('n', '<leader>ot', '<cmd>tag<space>')

  -- Save file as sudo
  map('c', 'w!!', '<cmd>w !sudo tee % >/dev/null')

  -- Move split to tab
  map('n', '<leader>mt', '<c-w><s-t>')

  -- Map to increment and decrement
  map('n', '+', '<C-a>')
  map('n', '-', '<C-x>')
  map('x', '+', 'g<C-a>')
  map('x', '-', 'g<C-x>')

  -- Open Lazygit
  map('n', '<leader>tlg', '<cmd>call OpenHTerm("lazygit", 0.8)<cr>')
  -- Open Lazydocker
  map('n', '<leader>tld', '<cmd>call OpenHTerm("lazydocker", 0.8)<cr>')

  -- Correct previous misspelled word ( Don't forgot to set spell )
  map('n', '<space>sp', 'mm[s1z=`m')
#+end_src

** remote yank
#+begin_src vimrc :tangle ./vim/rcfiles/remote-yank

nnoremap <leader>li :call RemoteYank('i')<cr>
nnoremap <leader>la :call RemoteYank('a')<cr>
nnoremap <leader>lr :call RemoteYank('r')<cr>

function! RemoteYank(dir)
  if &relativenumber
    echom "setting number"
    let was_relative = 1
    set number
    redraw!
  endif

  echohl String | let line = input("Remote link to yank: ") | echohl None
  if line == '' | return | endif

  execute line.'yank a'
  if a:dir == 'i'
    normal "aP
  elseif a:dir == 'a'
    normal "ap
  else
    normal V"ap
  endif

  if was_relative
    set relativenumber
  endif
endfunction

" vim:ft=vim
#+end_src

** remote yank (lua config)
#+begin_src lua

-- Remote yank

      map('n', '<leader>li', '<cmd>call RemoteYank("i")<cr>')
      map('n', '<leader>la', '<cmd>call RemoteYank("a")<cr>')
      map('n', '<leader>lr', '<cmd>call RemoteYank("r")<cr>')

    vim.api.nvim_exec([[
      function! RemoteYank(dir)
        if &relativenumber
          echom "setting number"
          let was_relative = 1
          set number
          redraw!
        endif

        echohl String | let line = input("Remote link to yank: ") | echohl None
        if line == '' | return | endif

        execute line.'yank a'
        if a:dir == 'i'
          normal "aP
        elseif a:dir == 'a'
          normal "ap
        else
          normal V"ap
        endif

        if was_relative
          set relativenumber
        endif
      endfunction
  ]], true)
#+end_src

** search
#+begin_src vimrc :tangle ./vim/rcfiles/search

" Searching stuff
set hlsearch                    " highlight searches, map below to clear
set incsearch                   " do incremental searching
set ignorecase                  " Case insensitive...
set smartcase                   " ...except if you use UCase

nnoremap <silent><leader><space> :nohl<cr>

" quick searching of vimrc files
function! s:VimrcSearch()
  echohl String | let text = input("Text to search: ") | echohl None
  if text == '' | return | endif
  execute "Rg ". text ." ~/.dotfiles/vim/rcfiles/* ~/.dotfiles/vim/rcplugins/*"
endfunction
command! VimrcSearch call <sid>VimrcSearch()
nnoremap <leader>sr :VimrcSearch<cr>

" Mappings for quick search & replace. Global set to default
" Do a / search first, then leave pattern empty in :s// to use previous
nnoremap <Leader>sub :%s///g<left><left>
vnoremap <Leader>sub :s///g<left><left>
nnoremap <leader>wub :%s//<C-r><C-w>/g<cr>

" Search for selected text, forwards or backwards.
" http://vim.wikia.com/wiki/Search_for_visually_selected_text
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

nnoremap Q @q
vnoremap Q :normal Q<cr>

" vim:ft=vim
#+end_src

** search (lua config)
#+begin_src lua
-- Search

opt.hlsearch = true                    -- highlight searches, map below to clear
opt.incsearch = true                   -- do incremental searching
opt.ignorecase = true                  -- Case insensitive...
opt.smartcase = true                   -- ...except if you use UCase

map('n', '<silent><leader><space>', '<cmd>nohl<cr>')

-- quick searching of vimrc files
vim.api.nvim_exec([[
function! VimrcSearch()
  echohl String | let text = input("Text to search: ") | echohl None
  if text == '' | return | endif
  execute "Rg ". text ." ~/.emacs.d/vim/init.lua"
endfunction
]], true)
vim.api.nvim_command("command! VimrcSearch call <sid>VimrcSearch()")
map('n', '<leader>sr', '<cmd>VimrcSearch<cr>')

-- Mappings for quick search & replace. Global set to default
-- Do a / search first, then leave pattern empty in :s// to use previous
map('n', '<Leader>sub', [[:%s///g<left><left>]])
map('v', '<Leader>sub', [[:s///g<left><left>]])
map('n', '<leader>wub', [[:%s//<C-r><C-w>/g<cr>]])

map('n', 'Q', '@q')
map('v', 'Q', '<cmd>normal Q<cr>')
#+end_src

** statusline
For general info on statusline, start with the :h, then see [[http://got-ravings.blogspot.com/2008/08/vim-pr0n-making-statuslines-that-own.html][this link]]
NOTE: NSFW, but very good overview of statusling configuration

#+begin_src vimrc :tangle ./vim/rcfiles/statusline

"Use this to prevent some settings from reloading
let g:vimrc_loaded = 1

set laststatus=2 " Always show the statusline

"define 3 custom highlight groups
hi User1 ctermbg=lightgray ctermfg=yellow guifg=orange guibg=#444444 cterm=bold gui=bold
hi User2 ctermbg=lightgray ctermfg=red guifg=#dc143c guibg=#444444 gui=none
hi User3 ctermbg=lightgray ctermfg=red guifg=#ffff00 guibg=#444444 gui=bold

set statusline= " Clear the statusline for vimrc reloads

set stl=%*                        " Normal statusline highlight
set stl^=%{coc#status()}%{get(b:,'coc_current_function','')} " coc status line
set stl+=%{fugitive#statusline()} " Current branch
set stl+=%{InsertSpace()}         " Put a leading space in

set stl+=%1*                      " Red highlight
set stl+=%{HasPaste()}            " Red show paste
set stl+=%*                       " Return to normal stl hilight

set stl+=%-40f\                   " Filename

set stl+=%2*                      " Red highlight
set stl+=%m                       " Modified flag

set stl+=%*                       " Return to normal stl hilight
set stl+=%r                       " Readonly flag
set stl+=%h                       " Help file flag

set stl+=%*                       " Set to 3rd highlight
set stl+=\ %y                     " Filetype

set stl+=%=                       " Right align from here on
set statusline+=%{SlSpace()}      " Vim-space plugin current setting
set stl+=\ \ Col:%c               " Column number
set stl+=\ \ Line:%l/%L           " Line # / total lines
set stl+=\ \ %P%{InsertSpace()}   " Single space buffer

" set stl+=%2*                    " Yello highlight
" set stl+=%*                     " Return to normal stl hilight

function! SlSpace()
  if exists("*GetSpaceMovement")
    return "[" . GetSpaceMovement() . "]"
  else
    return ""
  endif
endfunc

function! InsertSpace()
  " For adding trailing spaces onto statusline
  return ' '
endfunction

function! HasPaste()
  if &paste
    return '[PASTE]'
  else
    return ''
  endif
endfunction

function! CurDir()
  let curdir = substitute(getcwd(), '/Users/pablobfonseca/', "~/", "g")
  return curdir
endfunction

" vim:ft=vim
#+end_src

** statusline (lua config)
#+begin_src lua
  -- Statusline

  -- Use this to prevent some settings from reloading
  g.vimrc_loaded = 1

  opt.laststatus=2 -- Always show the statusline

  -- define 3 custom highlight groups
  vim.api.nvim_command("hi User1 ctermbg=lightgray ctermfg=yellow guifg=orange guibg=#444444 cterm=bold gui=bold")
  vim.api.nvim_command("hi User2 ctermbg=lightgray ctermfg=red guifg=#dc143c guibg=#444444 gui=none")
  vim.api.nvim_command("hi User3 ctermbg=lightgray ctermfg=red guifg=#ffff00 guibg=#444444 gui=bold")

  opt.statusline=''

  opt.statusline = '%*'
  opt.statusline:append("%{InsertSpace()}")

  opt.statusline:append("%1*")
  opt.statusline:append("%{HasPaste()}")
  opt.statusline:append("%*")

  opt.statusline:append("%-40f ")

  opt.statusline:append("%2*")
  opt.statusline:append("%m")

  opt.statusline:append("%*")
  opt.statusline:append("%r")
  opt.statusline:append("%h")

  opt.statusline:append("%*")
  opt.statusline:append([[  %y]])

  opt.statusline:append("%=")
  opt.statusline:append("%{SlSpace()}")
  opt.statusline:append("  Col:%c")
  opt.statusline:append("  Line:%l/%L")
  opt.statusline:append("  %P%{InsertSpace()}")

  vim.api.nvim_exec([[
    function! SlSpace()
      if exists("*GetSpaceMovement")
        return "[" . GetSpaceMovement() . "]"
      else
        return ""
      endif
    endfunc

    function! InsertSpace()
      " For adding trailing spaces onto statusline
      return ' '
    endfunction

    function! HasPaste()
      if &paste
        return '[PASTE]'
      else
        return ''
      endif
    endfunction

    function! CurDir()
      let curdir = substitute(getcwd(), '/Users/pablobfonseca/', "~/", "g")
      return curdir
    endfunction
  ]], true)

#+end_src

** tags
#+begin_src vimrc :tangle ./vim/rcfiles/tags

set tags^=./.git/tags

augroup tags_stuff
  " Clear old autocmds in group
  autocmd FileType * call EnableTagNavMaps()
augroup END

function! EnableTagNavMaps()
  if s:BufferIsTagNavigable()
    nmap <buffer> <bs> <c-t>
  endif
endfunction

let s:navigable_filetypes = ['vim', 'ruby', 'javascript', 'sh']

function! s:BufferIsTagNavigable()
  let is_navigable_filetype = index(s:navigable_filetypes, &filetype) != -1
  let is_normal_buffer = &buftype !=? 'nofile'
  return is_navigable_filetype && is_normal_buffer
endfunction

" Generate ctags
nnoremap <Leader>rt :!ctags --tag-relative --extras=+f -Rf .git/tags --languages=-javascript,sql<CR>

function! s:RebuildTagsFile()
  !ctags -R --exclude=coverage --exclude=files --exclude=public --exclude=log --exclude=tmp --exclude=vendor *
endfunction
command! -nargs=0 RebuildTagsFile call s:RebuildTagsFile()

" vim:ft=vim
#+end_src

** tags (lua config)
#+begin_src lua
  -- Tags

  opt.tags:prepend({"./.git/tags"})
#+end_src

** terminal
#+begin_src vimrc :tangle ./vim/rcfiles/terminal

augroup terminal
  " Clear old autocmds in group
  autocmd!

  if has('nvim')
    autocmd BufEnter * if &buftype == 'terminal' | :startinsert | endif

    " Quit term buffer with Esc
    tnoremap <silent> <Esc> <C-\><C-n><cr>

    " use alt+hjkl to move between split/vsplit panels
    tnoremap <c-h> <C-\><C-n><C-w>h
    tnoremap <c-j> <C-\><C-n><C-w>j
    tnoremap <c-k> <C-\><C-n><C-w>k
    tnoremap <c-l> <C-\><C-n><C-w>l
    function! OpenTerminal()
      split | terminal
      split term:///bin/zsh
      resize 10
    endfunction
  " Open Terminal on Ctrl+n
    nnoremap <C-x>n :call OpenTerminal()<cr>
  endif
augroup END

" vim:ft=vim
#+end_src

** terminal (lua config)
#+begin_src lua

-- Terminal config

cmd 'augroup terminal'
  -- Clear old autocmds in group
  cmd 'autocmd!'

  cmd 'autocmd BufEnter * if &buftype == "terminal" | :startinsert | endif'

  -- Quit term buffer with Esc
  map('t', '<silent> <Esc>', [[<C-\><C-n><cr>]])

  -- use alt+hjkl to move between split/vsplit panels
  map('t', '<c-h>', [[<C-\><C-n><C-w>h]])
  map('t', '<c-j>', [[<C-\><C-n><C-w>j]])
  map('t', '<c-k>', [[<C-\><C-n><C-w>k]])
  map('t', '<c-l>', [[<C-\><C-n><C-w>l]])

  vim.api.nvim_exec([[
    function! OpenTerminal()
      split | terminal
      split term:///bin/zsh
      resize 10
    endfunction
  ]], true)
  -- Open Terminal on Ctrl+n
  map('n', '<C-x>n', '<cmd>call OpenTerminal()<cr>')
cmd 'augroup END'
#+end_src

** vim
#+begin_src vimrc :tangle ./vim/rcfiles/vim

augroup vim_stuff
  " Clear old autocmds in group
  autocmd!
  " automatically rebalance windows on vim resize
  autocmd VimResized * :wincmd =
  " Execute the vim current vim command line
  autocmd Filetype vim nnoremap <leader>x :execute getline(".")<cr>

  " Wrap the quickfix window
  autocmd FileType qf setlocal wrap linebreak
  autocmd BufWritePre * :call s:MkNonExDir(expand('<afile>'), +expand('<abuf>'))
  autocmd BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" Functions

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
nnoremap <Leader>rr :call RenameFile()<cr>

function! CmdLine(str)
  exe "menu Foo.Bar :" . a:str
  emenu Foo.Bar
  unmenu Foo
endfunction

function! VisualSelection(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'gv'
    call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

function! s:MkNonExDir(file, buf)
  if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
    let dir=fnamemodify(a:file, ':h')
    if !isdirectory(dir)
      call mkdir(dir, 'p')
    endif
  endif
endfunction

function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
vnoremap <silent> <Leader>al :Align<CR>

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

" TODO: Create a function to search gems right from vim
function! SearchForCallSitesCursor()
  let searchTerm = expand("<cword>")
  call SearchForCallSites(searchTerm)
endfunction

" Search for call sites for term (excluding its definition) and
" load into the quickfix list.
function! SearchForCallSites(term)
  cexpr system('ag ' . shellescape(a:term) . '\| grep -v def')
endfunction

" vim:ft=vim
#+end_src

** vim (lua config)
#+begin_src lua

    -- Vim config

    cmd 'augroup vim_stuff'
      -- Clear old autocmds in group
      cmd 'autocmd!'
      -- automatically rebalance windows on vim resize
      cmd 'autocmd VimResized * :wincmd ='
      -- Execute the vim current vim command line
      cmd 'autocmd Filetype vim nnoremap <leader>x :execute getline(".")<cr>'

      -- Wrap the quickfix window
      cmd 'autocmd FileType qf setlocal wrap linebreak'
      cmd 'autocmd BufWritePre * :call MkNonExDir(expand("<afile>"), +expand("<abuf>"))'
      cmd 'autocmd BufWinEnter *.txt if &ft == "help" | wincmd L | endif'
    cmd 'augroup END'

    -- Functions

  vim.api.nvim_exec([[
    function! RenameFile()
      let old_name = expand('%')
      let new_name = input('New file name: ', expand('%'), 'file')
      if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
      endif
    endfunction
  ]], true)
  map('n', '<Leader>rr', '<cmd>call RenameFile()<cr>')

  vim.api.nvim_exec([[
  function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
  endfunction

    function! VisualSelection(direction) range
      let l:saved_reg = @"
      execute "normal! vgvy"

      let l:pattern = escape(@", '\\/.*$^~[]')
      let l:pattern = substitute(l:pattern, "\n$", "", "")

      if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
      elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
      elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
      elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
      endif

      let @/ = l:pattern
      let @" = l:saved_reg
    endfunction

    function! MkNonExDir(file, buf)
      if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
        let dir=fnamemodify(a:file, ':h')
        if !isdirectory(dir)
          call mkdir(dir, 'p')
        endif
      endif
    endfunction

    function! AlignSection(regex) range
      let extra = 1
      let sep = empty(a:regex) ? '=' : a:regex
      let maxpos = 0
      let section = getline(a:firstline, a:lastline)
      for line in section
        let pos = match(line, ' *'.sep)
        if maxpos < pos
          let maxpos = pos
        endif
      endfor
      call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
      call setline(a:firstline, section)
    endfunction
    command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')

    function! AlignLine(line, sep, maxpos, extra)
      let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
      if empty(m)
        return a:line
      endif
      let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
      return m[1] . spaces . m[2]
    endfunction

    " TODO: Create a function to search gems right from vim
    function! SearchForCallSitesCursor()
      let searchTerm = expand("<cword>")
      call SearchForCallSites(searchTerm)
    endfunction

    " Search for call sites for term (excluding its definition) and
    " load into the quickfix list.
    function! SearchForCallSites(term)
      cexpr system('ag ' . shellescape(a:term) . '\| grep -v def')
    endfunction
  ]], true)

map('v', '<silent> <Leader>al', '<cmd>Align<CR>')
#+end_src

** visual
#+begin_src vimrc :tangle ./vim/rcfiles/visual
colorscheme dracula
set visualbell

" Easy access to maximizing
nnoremap <C-_> <C-w>_

set splitbelow
set splitright

" Colors
set t_Co=256
hi Search guifg=#000000 guibg=#8dabcd guisp=#8dabcd gui=NONE ctermfg=NONE ctermbg=110 cterm=NONE
hi WarningMsg guifg=#bd4848 guibg=#f9f8ff guisp=#f9f8ff gui=bold ctermfg=131 ctermbg=15 cterm=bold
hi ErrorMsg guifg=#bd5353 guibg=NONE guisp=NONE gui=NONE ctermfg=131 ctermbg=NONE cterm=NONE

" Make it more obvious which paren I'm on
hi MatchParen cterm=none ctermbg=black ctermfg=yellow

hi! link Search CursorLine
hi! link SpellBad ErrorMsg
hi! link SpellCap ErrorMsg
hi! link Error ErrorMsg

nnoremap <leader>! :redraw!<cr>

" zoom a vim pane, <C-w>= to re-balance
nnoremap <leader>- :wincmd _<cr>:wincmd \|<cr>
nnoremap <leader>= :wincmd =<cr>

" vim:ft=vim
#+end_src

** visual (lua config)
#+begin_src lua

-- Visual config

  cmd 'colorscheme vendetta'

  opt.visualbell = true

  -- Easy access to maximizing
  map('n', '<C-_>', '<C-w>_')

  opt.splitbelow = true
  opt.splitright = true

  -- Colors
  vim.api.nvim_command('hi Search guifg=#000000 guibg=#8dabcd guisp=#8dabcd gui=NONE ctermfg=NONE ctermbg=110 cterm=NONE')
  vim.api.nvim_command('hi WarningMsg guifg=#bd4848 guibg=#f9f8ff guisp=#f9f8ff gui=bold ctermfg=131 ctermbg=15 cterm=bold')
  vim.api.nvim_command('hi ErrorMsg guifg=#bd5353 guibg=NONE guisp=NONE gui=NONE ctermfg=131 ctermbg=NONE cterm=NONE')

  -- Make it more obvious which paren I'm on
  vim.api.nvim_command('hi MatchParen cterm=none ctermbg=black ctermfg=yellow')

  vim.api.nvim_command('hi! link Search CursorLine')
  vim.api.nvim_command('hi! link SpellBad ErrorMsg')
  vim.api.nvim_command('hi! link SpellCap ErrorMsg')
  vim.api.nvim_command('hi! link Error ErrorMsg')

  map('n', '<leader>!', '<cmd>redraw!<cr>')

  -- zoom a vim pane, <C-w>= to re-balance
  map('n', '<leader>-', [[<cmd>wincmd _<cr>:wincmd \|<cr>]])
  map('n', '<leader>=', '<cmd>wincmd =<cr>')
#+end_src

** zsh
#+begin_src vimrc :tangle ./vim/rcfiles/zsh

augroup filetype_zsh
  " Clear old autocmds in group
  autocmd!
  " set shell syntax for zsh files
  autocmd FileType zsh set syntax=sh
  autocmd BufRead,BufNewFile *.zsh-theme set filetype=zsh
augroup END

command! ReformatCurlRequest silent %s/\s\(-.\{-}\)\s/
 \1 /g

" vim:ft=vim
#+end_src
** zsh (lua config)
#+begin_src lua

-- Zsh config

cmd 'augroup filetype_zsh'
  -- Clear old autocmds in group
  cmd 'autocmd!'
  -- set shell syntax for zsh files
  cmd 'autocmd FileType zsh set syntax=sh'
  cmd 'autocmd BufRead,BufNewFile *.zsh-theme set filetype=zsh'
cmd 'augroup END'

vim.api.nvim_command([[command! ReformatCurlRequest silent %s/\s\(-.\{-}\)\s/ \1 /g]])
#+end_src
* rcplugins
** Plugins (lua config)
*** paq-nvim
Install the package
#+begin_src shell :tangle no
git clone --depth=1 https://github.com/savq/paq-nvim.git \
    "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/pack/paqs/start/paq-nvim
#+end_src

**** plugins
#+begin_src lua
cmd 'packadd paq-nvim' -- load the package manager
local paq = require('paq-nvim').paq -- a convenient alias
paq {'savq/paq-nvim', opt = true} -- paq-nvim manages itself
paq {'nvim-lua/popup.nvim'}
paq {'nvim-lua/plenary.nvim'}
paq {'kyazdani42/nvim-web-devicons'}

#+end_src

** addon-mw-utils
#+begin_src vimrc :tangle ./vim/rcplugins/addon-mw-utils

Plug 'marcweber/vim-addon-mw-utils'

" vim:ft=vim
#+end_src
** addon-mw-utils (lua config)
#+begin_src lua
paq {'marcweber/vim-addon-mw-utils'}
#+end_src
** ale.vim
Ale.vim - Check syntax in Vim asynchronously and fix files, with Language Server Protocol (LSP) support

#+begin_src vimrc :tangle ./vim/rcplugins/ale

Plug 'dense-analysis/ale'

let g:ale_linters = { 'javascript': ['xo'] }
let g:ale_fixers = { 'javascript': ['xo'] }

" vim:ft=vim
#+end_src
** ale.vim (lua config)
#+begin_src lua

paq {'dense-analysis/ale'}

g.ale_linters = { javascript = {'xo'} }
g.ale_fixers = { javascript = {'xo'} }
#+end_src
** animate.vim
A Vim Windown Animation Library

#+begin_src vimrc :tangle ./vim/rcplugins/animate

Plug 'camspiers/animate.vim'

let g:animate#easing_func = 'animate#ease_out_quad'
" vim: ft=vim
#+end_src
** animate.vim (lua config)
#+begin_src lua
paq {'camspiers/animate.vim'}

g['animate#easing_func'] = 'animate#ease_out_quad'
#+end_src
** any-jump
#+begin_src vimrc :tangle ./vim/rcplugins/any-jump
Plug 'pechorin/any-jump.vim'
" vim: ft=vim
#+end_src

** any-jump (lua config)
#+begin_src lua
paq {'pechorin/any-jump.vim'}
#+end_src

** coc
Intellisense engine for vim8

#+begin_src vimrc :tangle ./vim/rcplugins/coc

Plug 'neoclide/coc.nvim', {'branch': 'release'}

let g:coc_global_extensions = [
      \ 'coc-snippets',
      \ 'coc-pairs',
      \ 'coc-emmet',
      \ 'coc-tsserver',
      \ 'coc-json',
      \ 'coc-solargraph',
      \ 'coc-css',
      \ 'coc-python'
      \ ]

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Use <c-space> to trigger completion
" inoremap <silent><expr> <c-space> coc#refresh()
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<cr>"

inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Rename current word
nmap <F2> <Plug>(coc-rename)

" vim: ft=vim
#+end_src

*** Settings
#+begin_src json :tangle ./vim/coc-settings.json
  {
    "suggest.echodocSupport": true,
    "suggest.maxCompleteItemCount": 20,
    "suggest.enablePreview": true,
    "tsserver.enableJavascript": true,
    "coc.preferences.formatOnSaveFiletypes": ["rust", "elm"],
    "diagnostic.virtualText": true,
    "solargraph.hover": true,
    "solargraph.definitions": true,
    "solargraph.references": true,
    "codeLens.enable": true,
    "python.venvFolders": [ ".virtualenvs" ],
    "languageserver": {
      "cquery": {
        "command": "cquery",
        "args": ["--log-file=/tmp/cq.log"],
        "filetypes": ["c", "cpp"],
        "rootPatterns": ["compile_flags.txt", "compile_commands.json", ".vim/", ".git/", ".hg/"],
        "initializationOptions": {
          "cacheDirectory": "/tmp/cquery"
        }
      },
      "golang": {
        "command": "gopls",
        "rootPatterns": ["go.mod"],
        "filetypes": ["go"]
      },
      "efm": {
        "command": "efm-langserver",
        "args": [],
        "filetypes": ["vim", "eruby", "markdown"]
      },
      "rust": {
        "command": "rust-analyzer",
        "filetypes": ["rust"],
        "rootPatterns": ["Cargo.toml"]
      },
      "haskell": {
        "command": "hie-wrapper",
        "args": ["--lsp"],
        "rootPatterns": [
          "stack.yaml",
          "cabal.config",
          "package.yaml"
        ],
        "filetypes": [
          "hs",
          "lhs",
          "haskell"
        ],
        "initializationOptions": {
          "languageServerHaskell": {
            "hlintOn": true
          }
        }
      },
      "reason": {
        "command": "reason-language-server",
        "filetypes": ["reason"]
      },
      "elmLS": {
        "command": "elm-language-server",
        "filetypes": ["elm"],
        "rootPatterns": ["elm.json"],
        "initializationOptions": {
          "elmPath": "elm",
          "elmFormatPath": "elm-format",
          "elmTestPath": "elm-test",
          "elmAnalyseTrigger": "change"
        }
      }
    }
  }

#+end_src
** coc (lua config)
#+begin_src lua

  paq {'neoclide/coc.nvim', branch = 'release'}

  g.coc_global_extensions = {'coc-snippets', 'coc-pairs', 'coc-emmet', 'coc-tsserver', 'coc-json', 'coc-solargraph', 'coc-css', 'coc-python'}

  -- Remap keys for gotos
  map('n', '<silent> gd', '<Plug>(coc-definition)')
  map('n', '<silent> gy', '<Plug>(coc-type-definition)')
  map('n', '<silent> gi', '<Plug>(coc-implementation)')
  map('n', '<silent> gr', '<Plug>(coc-references)')
  map('n', '<silent> [g', '<Plug>(coc-diagnostic-prev)')
  map('n', '<silent> ]g', '<Plug>(coc-diagnostic-next)')

  map('i', '<silent><cr>', 'v:lua.smart_enter()', {expr = true, noremap = true})

  vim.api.nvim_exec([[
                function! CheckBackSpace() abort
                  let col = col('.') - 1
                  return !col || getline('.')[col - 1]  =~# '\s'
                endfunction
                ]], true)

  function _G.smart_tab()
     if vim.fn.pumvisible() == 1 then
        return t'<C-n>'
     elseif vim.fn['CheckBackSpace']() == 1 then
        return t'<TAB>'
     else
        return vim.fn['coc#refresh']()
     end
  end

  function _G.smart_s_tab()
     if vim.fn.pumvisible() == 1 then
        return t'<C-p>'
     else
        return t'<C-h>'
     end
  end

  map('i', '<TAB>', 'v:lua.smart_tab()', {expr = true, noremap = true})
  map('i', '<S-TAB>', 'v:lua.smart_s_tab()', {expr = true, noremap = true})

#+end_src
** coc-neco
viml completion source for coc.nvim

#+begin_src vimrc :tangle ./vim/rcplugins/coc-neco

Plug 'neoclide/coc-neco'
" vim: ft=vim
#+end_src
** coc-neco (lua config)
#+begin_src lua

paq {'neoclide/coc-neco'}
#+end_src
** commentary
Motion aware commenting

#+begin_src vimrc :tangle ./vim/rcplugins/commentary

Plug 'tpope/vim-commentary'

  vmap cm <Plug>Commentary
  vmap <M-/> <Plug>Commentary
  nmap cm <Plug>Commentary
  nmap cml <Plug>CommentaryLine
  nmap <M-/> <Plug>CommentaryLine
  " vim:ft=vim
#+end_src

** commentary (lua config)
#+begin_src lua
paq {'tpope/vim-commentary'}

map('v', 'cm', '<Plug>Commentary')
map('v', '<M-/>', '<Plug>Commentary')
map('n', 'cm', '<Plug>Commentary')
map('n', 'cml', '<Plug>CommentaryLine')
map('n', '<M-/>', '<Plug>CommentaryLine')

#+end_src

** dracula
#+begin_src vimrc :tangle ./vim/rcplugins/dracula
Plug 'Mofiqul/dracula.nvim'

" let g:termguicolors = true
" let g:dracula_show_end_of_buffer = true
" let g:dracula_transparent_bg = true

" vim: ft=vim
#+end_src

** dirbuf.nvim
#+begin_src vimrc :tangle ./vim/rcplugins/dirbuf
Plug 'elihunter173/dirbuf.nvim'
" vim: ft=vim
#+end_src

** easy-align
A Vim alignment plugin

#+begin_src vimrc :tangle ./vim/rcplugins/easy-align

Plug 'junegunn/vim-easy-align'

vmap <leader>ea <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" vim:ft=vim
#+end_src
** easy-align (lua config)
#+begin_src lua

paq {'junegunn/vim-easy-align'}

map('v', '<leader>ea', '<Plug>(EasyAlign)')
map('x', 'ga', '<Plug>(EasyAlign)')
map('n', 'ga', '<Plug>(EasyAlign)')
#+end_src
** easymotion
Vim motions on speed

#+begin_src vimrc :tangle ./vim/rcplugins/easymotion

Plug 'easymotion/vim-easymotion'

let g:EasyMotion_leader_key = '<leader><leader>'

" vim:ft=vim
#+end_src
** easymotion (lua config)
#+begin_src lua

paq {'easymotion/vim-easymotion'}

g.EasyMotion_leader_key = '<leader><leader>'
#+end_src
** emmet
Text expansion for html markup

#+begin_src vimrc :tangle ./vim/rcplugins/emmet

Plug 'mattn/emmet-vim',

let g:user_emmet_leader_key='<C-Z>'
let g:user_emmet_settings = {
      \ 'javascript.jsx' : {
      \   'extends': 'jsx',
      \},
    \}
let g:user_emmet_mode='a'

" vim:ft=vim
#+end_src
** emmet (lua config)
#+begin_src lua

paq {'mattn/emmet-vim'}

g.user_emmet_leader_key = '<C-Z>'
g.user_emmet_settings = { ["javascript.jsx"] = { extends = 'jsx'} }
g.user_emmet_mode = 'a'
#+end_src
** endwise
Intelligently insert ends, endifs, etc

#+begin_src vimrc :tangle ./vim/rcplugins/endwise

Plug 'tpope/vim-endwise'

" vim:ft=vim
#+end_src
** endwise (lua config)
#+begin_src lua

paq {'tpope/vim-endwise'}
#+end_src
** fugitive
Interact with git via Vim

#+begin_src vimrc :tangle ./vim/rcplugins/fugitive

Plug 'tpope/vim-fugitive'

nmap <leader>st :call <sid>SaveSessionAndShowGitStatus()<cr>
nmap <leader>ST :call <sid>RestoreSession()<cr>
nmap <leader>gd :Gdiff<cr>
nmap <leader>gb :Gblame<CR>

function! s:SaveSessionAndShowGitStatus()
  let session_name = split(getcwd(), "/")[-1]
  execute "silent! mksession! ~/.vim/sessions/" . session_name
  silent tabonly | silent only | Gstatus
endfunction

function! s:RestoreSession()
  let session_name = split(getcwd(), "/")[-1]
  execute "source ~/.vim/sessions/" . session_name
endfunction

set diffopt+=vertical

augroup git_stuff
  " Clear old autocmds in group
  autocmd!
  autocmd FileType gitcommit setl spell
  autocmd FileType gitcommit setl diffopt+=vertical
  autocmd FileType gitcommit nmap <buffer> <S-Tab> <C-p>
  autocmd FileType gitcommit nmap <buffer> <Tab> <C-n>
  autocmd BufRead,BufNewFile */.git/COMMIT_EDITMSG wincmd _
  autocmd BufEnter PULLREQ_EDITMSG setlocal filetype=gitcommit
augroup END

command! GitDiff call s:GitDiff()

" vim:ft=vim
#+end_src
** fugitive (lua config)
#+begin_src lua

  paq {'tpope/vim-fugitive'}

  map('n', '<leader>st', '<cmd>call SaveSessionAndShowGitStatus()<cr>')
  map('n', '<leader>ST', '<cmd>call RestoreSession()<cr>')
  map('n', '<leader>gd', '<cmd>Gdiff<cr>')
  map('n', '<leader>gb', '<cmd>Gblame<CR>')

  vim.api.nvim_exec([[
      function! SaveSessionAndShowGitStatus()
        let session_name = split(getcwd(), "/")[-1]
        execute "silent! mksession! ~/.vim/sessions/" . session_name
        silent tabonly | silent only | Gstatus
      endfunction

      function! RestoreSession()
        let session_name = split(getcwd(), "/")[-1]
        execute "source ~/.vim/sessions/" . session_name
      endfunction
  ]], true)

  opt.diffopt:append({'vertical'})

  cmd 'augroup git_stuff'
    -- Clear old autocmds in group
    cmd 'autocmd!'
    cmd 'autocmd FileType gitcommit setl spell'
    cmd 'autocmd FileType gitcommit setl diffopt+=vertical'
    cmd 'autocmd FileType gitcommit nmap <buffer> <S-Tab> <C-p>'
    cmd 'autocmd FileType gitcommit nmap <buffer> <Tab> <C-n>'
    cmd 'autocmd BufRead,BufNewFile */.git/COMMIT_EDITMSG wincmd _'
    cmd 'autocmd BufEnter PULLREQ_EDITMSG setlocal filetype=gitcommit'
  cmd 'augroup END'

  vim.api.nvim_command('command! GitDiff call GitDiff()')
#+end_src
** fzf.vim
#+begin_src vimrc :tangle ./vim/rcplugins/fzf

"Plug '/usr/local/opt/fzf'
"Plug 'junegunn/fzf.vim'

"let g:fzf_command_prefix = 'Fzf'

"" Configure FZF to use a floating window configuration
"let $FZF_DEFAULT_OPTS = '--layout=reverse'

"if has('nvim')
"  let $FZF_DEFAULT_OPTS .= ' --inline-info'
"endif

"let g:fzf_colors =
"\ { 'fg':      ['fg', 'Normal'],
"  \ 'bg':      ['bg', 'Normal'],
"  \ 'hl':      ['fg', 'Comment'],
"  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
"  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
"  \ 'hl+':     ['fg', 'Statement'],
"  \ 'info':    ['fg', 'PreProc'],
"  \ 'border':  ['fg', 'Ignore'],
"  \ 'prompt':  ['fg', 'Conditional'],
"  \ 'pointer': ['fg', 'Exception'],
"  \ 'marker':  ['fg', 'Keyword'],
"  \ 'spinner': ['fg', 'Label'],
"  \ 'header':  ['fg', 'Comment'] }

"autocmd! FileType fzf
"autocmd FileType fzf set noshowmode noruler nonu

"nnoremap <leader>f :Find<cr>
"nnoremap <C-p> :AF<cr>
"nnoremap <C-f> :FzfGitFiles<cr>
"nnoremap <leader>gc :FzfFiles app/controllers<cr>
"nnoremap <leader>gj :FzfFiles app/assets/javascripts<cr>
"nnoremap <leader>gl :FzfFiles config/locales<cr>
"nnoremap <leader>gm :FzfFiles app/models<cr>
"nnoremap <leader>gs :FzfFiles spec<cr>
"nnoremap <leader>gv :FzfFiles app/views<cr>
"nnoremap <leader>gw :FzfFiles app/workers<cr>
"nnoremap <leader>gh :FzfFiles app/helpers<cr>
"nnoremap <leader>gsv :FzfFiles app/services<cr>
"nnoremap <leader>gpr :FzfFiles app/presenters<cr>
"nnoremap <leader>gy :FzfFiles app/assets/stylesheets<cr>
"nnoremap <leader>gf :FzfFiles spec/factories<cr>

"nnoremap <leader>rf :FzfFiles ~/.vim/rcfiles<cr>
"nnoremap <leader>rp :FzfFiles ~/.vim/rcplugins<cr>
"nnoremap <leader>df :FzfFiles ~/.dotfiles<cr>
"nnoremap <leader>fb :FzfBuffers<cr>
"nnoremap <leader>ft :FzfTags<cr>
"nnoremap <leader>fm :FzfMaps<cr>
"nnoremap <leader>fc :FzfCommits<cr>
"nnoremap gs :FzfGFiles?<cr>
"nnoremap <leader>bl :FzfBLines<cr>
"nnoremap <leader>fh :FzfHelpTags<cr>
"nnoremap <leader>fa :FzfAg<cr>

"imap <c-x><c-f> <plug>(fzf-complete-path)
"imap <c-x><c-k> <plug>(fzf-complete-word)
"imap <c-x><c-j> <plug>(fzf-complete-file-ag)
"imap <c-x><c-l> <plug>(fzf-complete-line)

"" Configures ripgrep with fzf
"" command! -bang -nargs=* FzfRg call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, {'options': '--delimiter : --nth 4..'}, <bang>0)
"" command! -bang -nargs=* Rgg call fzf#vim#grep("rg --no-ignore --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, {'options': '--delimiter : --nth 4..'}, <bang>0)

"" Augmenting Ag command using fzf#vim#with_preview function
""   * fzf#vim#with_preview([[options], preview window, [toggle keys...]])
""   * Preview script requires Ruby
""   * Install Highlight or CodeRay to enable syntax highlighting
""
""   :FzfAg  - Start fzf with hidden preview window that can be enabled with "?" key
""   :FzfAg! - Start fzf in fullscreen and display the preview window above
"command! -bang -nargs=* FzfAg
"      \ call fzf#vim#ag(<q-args>,
"      \                 <bang>0 ? fzf#vim#with_preview('up:60%')
"      \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
"      \                 <bang>0)

"" --column: Show column number
"" --line-number: Show line number
"" --no-heading: Do not show file headings in results
"" --fixed-strings: Search term as a literal string
"" --ignore-case: Case insensitive search
"" --no-ignore: Do not respect .gitignore, etc...
"" --hidden: Search hidden files and folders
"" --follow: Follow symlinks
"" --glob: Additional conditions for search (in this case ignore everything in the .git/ folder)
"" --color: Search color options
"command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>), 1, <bang>0)

"command! -bang -nargs=? -complete=dir FzfFiles
"      \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

"" All files
"command! -nargs=? -complete=dir AF
"      \ call fzf#run(fzf#wrap(fzf#vim#with_preview({
"      \ 'source': 'fd --type f --hidden --follow --exclude .git --no-ignore . '.expand(<q-args>)
"      \ })))
"nnoremap <leader>af :AF<cr>

"command! -bang -nargs=* GGrep
"      \ call fzf#vim#grep(
"      \   'git grep --line-number '.shellescape(<q-args>), 0,
"      \   fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)

" vim: ft=vim
#+end_src
** git-gutter
Shows a git diff in the gutter (sign column) " and stages/undoes hunks.

#+begin_src vimrc :tangle ./vim/rcplugins/git-gutter

Plug 'airblade/vim-gitgutter'

" Use fontawesome icons as signs
let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '~'
let g:gitgutter_sign_removed = '-'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed = '<'

nnoremap <leader>hv <Plug>GitGutterPreviewHunk

" vim:ft=vim
#+end_src
** gitsigns (lua config)
#+begin_src lua

paq {'lewis6991/gitsigns.nvim'}

require('gitsigns').setup{}

#+end_src
** go
Go development plugin for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/go

Plug 'fatih/vim-go', { 'for': 'go' }
" vim:ft=vim
#+end_src
** go (lua config)
#+begin_src lua

paq {'fatih/vim-go'}
#+end_src
** html5
Filetype settings for html5

#+begin_src vimrc :tangle ./vim/rcplugins/html5

Plug 'othree/html5.vim', { 'for': 'html' }

" vim:ft=vim
#+end_src
** json
Syntax highlighting for JSON

#+begin_src vimrc :tangle ./vim/rcplugins/json

" Fancy tricks with hiding quotes around attributes, includes ftdetect
Plug 'elzr/vim-json', {'for': 'json'}

let g:vim_json_syntax_conceal = 0

" vim:ft=vim
#+end_src
** lexima
#+begin_src vimrc :tangle ./vim/rcplugins/lexima

Plug 'cohama/lexima.vim'

" vim:ft=vim
#+end_src
** lexima (lua config)
#+begin_src lua

paq {'cohama/lexima.vim'}
#+end_src
** lsp
#+begin_src vimrc :tangle ./vim/rcplugins/lsp

Plug 'neovim/nvim-lspconfig'
Plug 'hrsh7th/nvim-compe'

" nnoremap <silent> gd <cmd>lua vim.lsp.buf.definition()<CR>
" nnoremap <silent> gD <cmd>lua vim.lsp.buf.declaration()<CR>
" nnoremap <silent> gr <cmd>lua vim.lsp.buf.references()<CR>
" nnoremap <silent> gi <cmd>lua vim.lsp.buf.implementation()<CR>
" nnoremap <silent> K <cmd>lua vim.lsp.buf.hover()<CR>
" nnoremap <silent> <C-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
" nnoremap <silent> <C-n> <cmd>lua vim.lsp.diagnostic.goto_prev()<CR>
" nnoremap <silent> <C-p> <cmd>lua vim.lsp.diagnostic.goto_next()<CR>

" autocmd BufWritePre *.js lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.jsx lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.py lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.rb lua vim.lsp.buf.formatting_sync(nil, 100)
" vim: ft=vim
#+end_src
** lsp (lua config)
#+begin_src lua

  --paq {'neovim/nvim-lspconfig'}
  --paq {'ojroques/nvim-lspfuzzy'}

  --local lsp = require 'lspconfig'
  --local lspfuzzy = require 'lspfuzzy'

  --lsp.pylsp.setup {}
  --lspfuzzy.setup {} -- Make the LSP client use FZF instead of quickfix list
  --lsp.tsserver.setup{}


  --map('n', '<space>,', '<cmd>lua vim.lsp.diagnostic.goto_prev()<cr>')
  --map('n', '<space>;', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>')
  --map('n', '<space>a', '<cmd>lua vim.lsp.buf.code_action()<CR>')
  --map('n', '<space>d', '<cmd>lua vim.lsp.buf.definition()<CR>')
  --map('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>')
  --map('n', '<space>h', '<cmd>lua vim.lsp.buf.hover()<CR>')
  --map('n', '<space>m', '<cmd>lua vim.lsp.buf.rename()<CR>')
  --map('n', '<space>r', '<cmd>lua vim.lsp.buf.references()<CR>')
  --map('n', '<space>s', '<cmd>lua vim.lsp.buf.document_symbol()<CR>')
#+end_src
** markdown
Syntax file for Markdowm files

#+begin_src vimrc :tangle ./vim/rcplugins/markdown

Plug 'tpope/vim-markdown', {'for': 'markdown'}

let g:markdown_fenced_languages = ['python', 'javascript', 'ruby', 'sh', 'yaml', 'javascript', 'go', 'html', 'vim', 'json', 'diff']

" vim:ft=vim
#+end_src
** matchit
Extended % open close pair matching

#+begin_src vimrc :tangle ./vim/rcplugins/matchit

Plug 'vim-scripts/matchit.zip'

" vim:ft=vim
#+end_src
** matchit (lua config)
#+begin_src lua

paq {'vim-scripts/matchit.zip'}
#+end_src
** moonscript-vim
MoonScript support for vim

#+begin_src vimrc :tangle ./vim/rcplugins/moonscript-vim

Plug 'leafo/moonscript-vim', { 'for': 'moonscript' }
" vim: ft=vim
#+end_src
** moonscript-vim (lua config)
#+begin_src lua

paq {'leafo/moonscript-vim'}
#+end_src
** neco-vim
The vim source for neocomplete/deoplete

#+begin_src vimrc :tangle ./vim/rcplugins/neco-vim

Plug 'Shougo/neco-vim'
" vim: ft=vim
#+end_src
** neco-vim (lua config)
#+begin_src lua

paq {'Shougo/neco-vim'}
#+end_src
** neoterm
Wrapper of some vim/neovim's :terminal functions

#+begin_src vimrc :tangle ./vim/rcplugins/neoterm

Plug 'kassio/neoterm'

nnoremap <leader>ro :Topen<cr>
" vim: ft=vim
#+end_src
** neoterm (lua config)
#+begin_src lua

paq {'kassio/neoterm'}

map('n', '<leader>ro', '<cmd>Topen<cr>', { noremap = true })
#+end_src
** nvim-spectre
#+begin_src vimrc :tangle ./vim/rcplugins/nvim-spectre
Plug 'windwp/nvim-spectre'

nnoremap <leader>S :lua require('spectre').open()<CR>

"search current word
vnoremap <leader>s :lua require('spectre').open_visual()<CR>
"  search in current file
nnoremap <leader>sp viw:lua require('spectre').open_file_search()<cr>

" vim: ft=vim
#+end_src
** perl
#+begin_src vimrc :tangle ./vim/rcplugins/perl

Plug 'wolfgangmehner/perl-support', { 'for': 'perl' }
" vim: ft=vim
#+end_src
** rails
Help for working with Rails projects in vim

#+begin_src vimrc :tangle ./vim/rcplugins/rails

Plug 'tpope/vim-rails'

nnoremap <leader>rs :Server<cr>
nnoremap <leader>rc :Console<cr>

let g:rails_projections = {
      \ 'app/services/*.rb': {
      \   'command': 'service',
      \ },
      \ 'app/mappers/*.rb': {'command': 'mapper'}}

" vim:ft=vim
#+end_src
** rails (lua config)
#+begin_src lua

paq {'tpope/vim-rails'}

map('n', '<leader>rs', '<cmd>Server<cr>', { noremap = true})
map('n', '<leader>rc', '<cmd>Console<cr>', { noremap = true})

g.rails_projections = {
   ['app/services/*.rb'] =  {
      command = 'service'
}}
#+end_src
** rake
it's like rails.vim without the rails

#+begin_src vimrc :tangle ./vim/rcplugins/rake

Plug 'tpope/vim-rake'

" vim: ft=vim
#+end_src
** rake (lua config)
#+begin_src lua

paq {'tpope/vim-rake'}
#+end_src
** ruby
#+begin_src vimrc :tangle ./vim/rcplugins/ruby

Plug 'vim-ruby/vim-ruby', {'for': 'ruby'}

" vim:ft=vim
#+end_src
** rust
Vim configuration for Rust

#+begin_src vimrc :tangle ./vim/rcplugins/rust

Plug 'rust-lang/rust.vim', {'for': 'rust'}
" vim: ft=vim
#+end_src
** splitjoin
Switch between single-line and multiline forms of code

#+begin_src vimrc :tangle ./vim/rcplugins/splitjoin

Plug 'AndrewRadev/splitjoin.vim', { 'branch': 'main' }
" vim: ft=vim
#+end_src
** splitjoin (lua config)
#+begin_src lua

paq {'AndrewRadev/splitjoin.vim', branch = 'main' }
#+end_src
** surround
Add, update, remove enclosing marks, ie [], {}. (), "", ''

#+begin_src vimrc :tangle ./vim/rcplugins/surround

Plug 'tpope/vim-surround'

let [s:single_quote, s:double_quote, s:no_match] = [1,2,0]
function! SurroundRequote()
    let matched_quote = s:no_match
    let [column, line] = [virtcol('.'), getline('.')]
    let offset = 1
    while offset < 30
        let matched_quote = s:QuoteStyle(line, column, offset)
        if matched_quote
            call s:SwapSurroundingQuotes(matched_quote)
            break
        endif
        let offset += 1
    endwhile
endfunction

function! s:SwapSurroundingQuotes(current_quote)
    if a:current_quote != s:single_quote && a:current_quote != s:double_quote
        return
    endif
    call s:CacheCursorLocation()
    let quote_sequence = a:current_quote == s:single_quote ? "'\"" : "\"'"
    execute "normal cs" . quote_sequence
    call s:RestoreCursorLocation()
endfunction

function! s:QuoteStyle(line, column, offset)
    let left_character = a:line[a:column - a:offset - 1]
    let right_character = a:line[a:column + a:offset - 1]
    if left_character == "'" || right_character == "'"
        return s:single_quote
    elseif left_character == '"' || right_character == '"'
        return s:double_quote
    endif
    return s:no_match
endfunction

function! s:CacheCursorLocation()
    execute "normal mm"
endfunction

function! s:RestoreCursorLocation()
    execute "normal `m"
endfunction

nmap <leader>c' :call SurroundRequote()<cr>

nmap <leader>qw ysiw"
nmap <leader>QW ysiW"

" vim:ft=vim
#+end_src
** surround (lua config)
#+begin_src lua
paq {'tpope/vim-surround'}
#+end_src
** telescope
Find, Filter, Preview, Pick. All lua, all the time.

#+begin_src vimrc :tangle ./vim/rcplugins/telescope
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plug 'nvim-telescope/telescope-fzf-native.nvim', { 'do': 'make' }
Plug 'kyazdani42/nvim-web-devicons'

nnoremap <C-p> <cmd>Telescope find_files<cr>
nnoremap <leader>f <cmd>Telescope live_grep<cr>
nnoremap <C-x>b <cmd>Telescope buffers<cr>
nnoremap gs <cmd>Telescope git_status<cr>

" vim: ft=vim
#+end_src
** telescope (lua config)
#+begin_src lua
paq {'nvim-telescope/telescope.nvim'}

map('n', '<C-p>', '<cmd>lua require("telescope.builtin").find_files()<cr>')
map('n', '<leader>f', '<cmd>lua require("telescope.builtin").live_grep()<cr>')
map('n', '<C-x>b', '<cmd>lua require("telescope.builtin").buffers()<cr>')
map('n', 'gs', '<cmd>lua require("telescope.builtin").git_status()<cr>')
#+end_src
** textobj-word-column
Adds text-objects for word-based columns in Vim.

#+begin_src vimrc :tangle ./vim/rcplugins/textobj-word-column

Plug 'coderifous/textobj-word-column.vim'

" vim:ft=vim
#+end_src
** textobj-word-column (lua config)
#+begin_src lua

paq {'coderifous/textobj-word-column.vim'}
#+end_src
** tree-sitter (lua config)
#+begin_src lua
  paq {'nvim-treesitter/nvim-treesitter', run = fn[':TSUpdate']}
  local ts = require 'nvim-treesitter.configs'
  ts.setup {ensure_installed = 'maintained', highlight = {enable = true}}

#+end_src

** typescript
Typescript syntax files for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/typescript

Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }

let g:typescript_compiler_binary='tsc'
" vim: ft=vim
#+end_src
** unimpaired
Pairs of handy bracket mappings

#+begin_src vimrc :tangle ./vim/rcplugins/unimpaired

Plug 'tpope/vim-unimpaired'

" vim:ft=vim
#+end_src
** unimpaired (lua config)
#+begin_src lua

paq {'tpope/vim-unimpaired'}
#+end_src
** vim-dispatch
Asynchronous build and test dispatcher

#+begin_src vimrc :tangle ./vim/rcplugins/vim-dispatch

Plug 'tpope/vim-dispatch'

nnoremap d<cr> :Dispatch<space>
nnoremap <leader>co :Copen<cr>
nnoremap <leader>cop :Copen!<cr>
" vim: ft=vim
#+end_src
** vim-dispatch (lua config)
#+begin_src lua

  paq {'tpope/vim-dispatch'}

  map('n', 'd<cr>', ':Dispatch<space>', { noremap = true })
  map('n', '<leader>co', '<cmd>Copen<cr>', { noremap = true })
  map('n', '<leader>cop', '<cmd>Copen!<cr>', { noremap = true })
#+end_src
** vim-elm
Elm plugin for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-elm

Plug 'Zaptic/elm-vim', {'for': 'elm'}
" vim: ft=vim
#+end_src
** vim-javascript
Vastly improved Javascript indentation and syntax support in Vim.

#+begin_src vimrc :tangle ./vim/rcplugins/vim-javascript

Plug 'pangloss/vim-javascript', {'for': ['javascript', 'html']}

let g:javascript_plugin_jsdoc = 1
let g:javascript_plugin_flow = 1
" vim: ft=vim
#+end_src
** vim-jsx
React JSX syntax highlighting and indenting for vim.

#+begin_src vimrc :tangle ./vim/rcplugins/vim-jsx

Plug 'mxw/vim-jsx'
" vim: ft=vim
#+end_src
** vim-jsx-typescript
React JSX syntax highlighting for vim and Typescript

#+begin_src vimrc :tangle ./vim/rcplugins/vim-jsx-typescript

Plug 'peitalin/vim-jsx-typescript', {'for': 'tsx'}
" vim: ft=vim
#+end_src
** vim-peekaboo
Extends `"` and `@` so you can see the contents of registers

#+begin_src vimrc :tangle ./vim/rcplugins/vim-peekaboo

Plug 'junegunn/vim-peekaboo'
" vim: ft=vim
#+end_src
** vim-peekaboo (lua config)
#+begin_src lua

paq {'junegunn/vim-peekaboo'}
#+end_src
** vim-polyglot
A solid language pack for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-polyglot

Plug 'sheerun/vim-polyglot'
" vim: ft=vim
#+end_src
** vim-projectionist
Granular project configuration

#+begin_src vimrc :tangle ./vim/rcplugins/vim-projectionist

Plug 'tpope/vim-projectionist'
" vim:ft=vim
#+end_src
** vim-reek
Code smell detector for Ruby in Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-reek

Plug 'rainerborene/vim-reek', { 'for': 'ruby' }
let g:reek_on_loading = 0
let g:reek_always_show = 0
" vim: ft=vim
#+end_src
** vim-repeat
Enable repeating supported plugin maps with "."

#+begin_src vimrc :tangle ./vim/rcplugins/vim-repeat

Plug 'tpope/vim-repeat'

" vim: ft=vim
#+end_src
** vim-repeat (lua config)
#+begin_src lua

paq {'tpope/vim-repeat'}
#+end_src
** vim-ripgrep
Use RipGrep in Vim and display results in a quickfix list

#+begin_src vimrc :tangle ./vim/rcplugins/vim-ripgrep

Plug 'guohao117/vim-ripgrep'

" Allow Ripgrep to work with quick list
command! -nargs=* -complete=file Ripgrep :call s:Rg(<q-args>)>
command! -nargs=* -complete=file Rg :call s:Rg(<q-args>)
" vim: ft=vim
#+end_src
** vim-ripgrep (lua config)
#+begin_src lua

paq {'guohao117/vim-ripgrep'}

-- Allow Ripgrep to work with quick list
vim.api.nvim_command('command! -nargs=* -complete=file Ripgrep :call Rg(<q-args>)>')
vim.api.nvim_command('command! -nargs=* -complete=file Rg :call Rg(<q-args>)')
#+end_src
** vim-rsi
Readline style insertion

#+begin_src vimrc :tangle ./vim/rcplugins/vim-rsi

Plug 'tpope/vim-rsi'

" vim:ft=vim
#+end_src
** vim-rsi (lua config)
#+begin_src lua

paq {'tpope/vim-rsi'}
#+end_src
** vim-test
Run your tests at the speed of thought

#+begin_src vimrc :tangle ./vim/rcplugins/vim-test

Plug 'janko-m/vim-test'

let test#strategy = 'neovim'

" vim: ft=vim
#+end_src
** vim-visual-multi
Multiple cursors plugin for vim/neovim
#+begin_src vimrc :tangle ./vim/rcplugins/vim-visual-multi

Plug 'mg979/vim-visual-multi'
" vim: ft=vim
#+end_src
** vim-visual-multi (lua config)
#+begin_src lua

paq {'mg979/vim-visual-multi'}
#+end_src
** vim-xo
Vim plugin for XO

#+begin_src vimrc :tangle ./vim/rcplugins/vim-xo

Plug 'xojs/vim-xo', { 'branch': 'main' }
" vim: ft=vim
#+end_src
** vim-xo (lua config)
#+begin_src lua

paq {'xojs/vim-xo', branch = 'main' }
#+end_src
** webapi
#+begin_src vimrc :tangle ./vim/rcplugins/webapi

Plug 'mattn/webapi-vim'

" vim:ft=vim
#+end_src
** webapi (lua config)
#+begin_src lua

paq {'mattn/webapi-vim'}
#+end_src
** xml
Handles xml files

#+begin_src vimrc :tangle ./vim/rcplugins/xml

augroup filetype_ruby
  autocmd BufWritePre * filetype xml :PrettyXML()
augroup END

function! s:PrettyXML()
  %!xmllint --format -
  set filetype=xml
endfunction
command! PrettyXML :call <sid>PrettyXML()
" vim: ft=vim
#+end_src

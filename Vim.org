#+TITLE: @pablobfonseca's VIM Configuration
#+PROPERTY: header-args:vimrc :tangle ./vim/vimrc :mkdirp yes

* Welcome to my Vim config
This file generates [[file:vimrc][vimrc]] file which can be loaded by VIM at startup.
#+begin_src vimrc
"
"        _
" __   _(_)_ __ ___
" \ \ / / | '_ ` _ \
"  \ V /| | | | | | |
"   \_/ |_|_| |_| |_|
"
" File: vimrc
" Author: Pablo Fonseca <pablofonseca777@gmail.com>
" Description: VIM Rocks!
" Source: http://github.com/pablobfonseca/dotfiles
#+end_src

* Setup
#+begin_src vimrc
  let mapleader=","
  let maplocalleader="-"

  filetype off
  filetype plugin indent on

  autocmd!
  set nocompatible
#+end_src
** Source Config Files


The ~SourceConfigFilesIn~ function takes a directory and eval the files inside that directory
#+begin_src vimrc
function! s:SourceConfigFilesIn(directory)
  let directory_splat = '~/.vim/' . a:directory . '/*'
  for config_file in split(glob(directory_splat), '\n')
    if filereadable(config_file)
      execute 'source' config_file
    endif
  endfor
endfunction
#+end_src
** Plugin Setup

Setup Plug to manage my plugins

Plugins are each listed in their own file. Loop and source them using the ~SourceConfigFilesIn~
#+begin_src vimrc
call plug#begin('~/.vim/plugged')

call s:SourceConfigFilesIn('rcplugins')

call plug#end()
#+end_src
* rcfiles
Vimrc is split accross multiple files, so loop over and source each

#+begin_src vimrc
call s:SourceConfigFilesIn('rcfiles')
#+end_src

** background-command
#+begin_src vimrc :tangle ./vim/rcfiles/background-command

" This callback will be executed when the entire command is completed
function! BackgroundCommandClose(channel)
  " Read the output from the command into the quickfix window
  execute "cfile! " . g:backgroundCommandOutput
  " Open the quickfix window
  copen
  unlet g:backgroundCommandOutput
endfunction

function! RunBackgroundCommand(command)
  " Make sure we're running VIM version 8 or higher.
  if v:version < 800
    echoerr 'RunBackgroundCommand requires VIM version 8 or higher'
    return
  endif

  if exists('g:backgroundCommandOutput')
    echo 'Already running task in background'
  else
    echo 'Running task in background'
    " Launch the job.
    " Notice that we're only capturing out, and not err here. This is because, for some reason, the callback
    " will not actually get hit if we write err out to the same file. Not sure if I'm doing this wrong or?
    let g:backgroundCommandOutput = tempname()
    call job_start(a:command, {'close_cb': 'BackgroundCommandClose', 'out_io': 'file', 'out_name': g:backgroundCommandOutput})
  endif
endfunction

" So we can use :BackgroundCommand to call our function.
command! -nargs=+ -complete=shellcmd RunBackgroundCommand call RunBackgroundCommand(<q-args>)

nnoremap <leader>bc :RunBackgroundCommand

" vim: ft=vim
#+end_src

** chrome
#+begin_src vimrc :tangle ./vim/rcfiles/chrome

" Chrome Cli bindings
function! s:HasFile()
  return expand("%") != ""
endfunction

function! s:OpenTab(reload, detached)
  let open_tab_command = "open-tab"
  if s:HasFile()
    update
  endif

  if a:reload
    let open_tab_command .= " --reload"
  endif

  if a:detached
    let open_tab_command .= " --detached"
  endif

  if exists("g:app_url")
    let open_tab_command .= " " . g:app_url
  endif
  call system(open_tab_command)
endfunction

command! OpenAndReloadTab call <sid>OpenTab(1, 0)
command! OpenTab call <sid>OpenTab(0, 0)
command! OpenTabDetached call <sid>OpenTab(0, 1)
nnoremap gl <silent> :OpenAndReloadTab<cr>
nnoremap gL <silent> :OpenTabDetached<cr>

nnoremap <leader>gr :!chrome-cli reload<cr><cr>
" vim: ft=vim
#+end_src
** command line
#+begin_src vimrc :tangle ./vim/rcfiles/command-line
cnoremap <C-k> <up>
cnoremap <C-j> <down>

cnoremap <C-x><C-e> <C-e><C-f>

cnoremap %% <C-R>=expand('%:h').'/'<cr>

" vim:ft=vim
#+end_src

** folding
#+begin_src vimrc :tangle ./vim/rcfiles/folding

"Enable indent folding
set foldenable
set foldmethod=indent
set foldlevel=999

" Quick fold to level 1, especially useful for Coffeescript class files
nmap <leader>fld :set foldlevel=1<cr>

"Maps for folding, unfolding all
nnoremap <leader>fu zM<CR>
nnoremap <leader>uf zR<CR>

"Maps for setting foldleve
nnoremap <leader>fl1 :set foldlevel=1<cr>
nnoremap <leader>fl2 :set foldlevel=2<cr>
nnoremap <leader>fl3 :set foldlevel=3<cr>
nnoremap <leader>fl4 :set foldlevel=4<cr>

" Focus the current fold by closing all others
nnoremap <leader>flf mzzM`zzv

" Set foldlevel to match current line
nnoremap <leader>flc :execute 'set foldlevel=' . foldlevel('.')<cr>

" vim:ft=vim
#+end_src

** functional
Functional vimscript helpers
Taken from [[ http://learnvimscriptthehardway.stevelosh.com/chapters/39.html][here]]

#+begin_src vimrc :tangle ./vim/rcfiles/functional

function! Sorted(l)
    let new_list = deepcopy(a:l)
    call sort(new_list)
    return new_list
endfunction

function! Reversed(l)
    let new_list = deepcopy(a:l)
    call reverse(new_list)
    return new_list
endfunction

function! Append(l, val)
    let new_list = deepcopy(a:l)
    call add(new_list, a:val)
    return new_list
endfunction

function! Assoc(l, i, val)
    let new_list = deepcopy(a:l)
    let new_list[a:i] = a:val
    return new_list
endfunction

function! Pop(l, i)
    let new_list = deepcopy(a:l)
    call remove(new_list, a:i)
    return new_list
endfunction

function! Mapped(list, fn)
    let new_list = deepcopy(a:list)
    let FuncRef = function(a:fn)
    call map(new_list, string(FuncRef) . '(v:val)')
    return new_list
endfunction

function! NewFZFWindow() abort
  new | wincmd J | resize 1
endfunction

" Creates a floating window with a most recent buffer to be used
function! CreateCenteredFloatingWindow()
  if has('nvim')
    let width = float2nr(&columns * 0.8)
    let height = float2nr(&lines * 0.8)
    let top = ((&lines - height) / 2) - 1
    let left = (&columns - width) / 2
    let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

    let top = '╭' . repeat('─', width - 2) . '╮'
    let mid = '│' . repeat(' ', width - 2) . '│'
    let bot = '╰' . repeat('─', width - 2) . '╯'
    let lines = [top] + repeat([mid], height - 2) + [bot]
    let s:buf = nvim_create_buf(v:false, v:true)
    call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
    call nvim_open_win(s:buf, v:true, opts)
    set winhl=Normal:Floating
    let opts.row += 1
    let opts.height -= 2
    let opts.col += 2
    let opts.width -= 4
    call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
    autocmd BufWipeout <buffer> call CleanupBuffer(s:buf)
    tnoremap <buffer> <silent> <Esc> <C-\><C-n><CR>:call DeleteUnlistedBuffers()<CR>
  endif
endfunction

function! OnTermExit(job_id, code, event) dict
  if has('nvim')
    if a:code == 0
      call DeleteUnlistedBuffers()
    endif
  endif
endfunction

function! DeleteUnlistedBuffers()
  if has('nvim')
    for n in nvim_list_bufs()
      if ! buflisted(n)
        let name = bufname(n)
        if name == '[Scratch]' ||
              \ matchend(name, ':bash') ||
              \ matchend(name, ':zsh')
          call CleanupBuffer(n)
        endif
      endif
    endfor
  endif
endfunction

function! CleanupBuffer(buf)
  if has('nvim')
    if bufexists(a:buf)
      silent execute 'bwipeout! '.a:buf
    endif
  endif
endfunction

function! ToggleTerm(cmd)
  if has('nvim')
    if empty(bufname(a:cmd))
      call CreateCenteredFloatingWindow()
      call termopen(a:cmd, { 'on_exit': function('OnTermExit') })
    else
      call DeleteUnlistedBuffers()
    endif
  endif
endfunction

function! ToggleScratchTerm()
  if has('nvim')
    call ToggleTerm('zsh')
  endif
endfunction
command! ToggleScratchTerm call ToggleScratchTerm()

" When term starts, auto go into insert mode
if has('nvim')
  autocmd TermOpen * startinsert

  " Turn off line numbers etc
  autocmd TermOpen * setlocal listchars= nonumber norelativenumber
endif

" Remove current file - Extracted from tpope's vim-eunuch plugin
command! -bar -bang Remove
      \ let s:file = fnamemodify(bufname(<q-args>),':p') |
      \ execute 'bdelete<bang>' |
      \ if !bufloaded(s:file) && delete(s:file) |
      \   echoerr 'Failed to delete "'.s:file.'"' |
      \ endif |
      \ unlet s:file

" Create new plugin file
function! s:NewPlugin()
  echohl String | let text = input('Plugin name: ') | echohl None
  if text ==# '' | return | endif
  execute 'e ~/.vim/rcplugins/' . text
  execute 'set filetype=vim'
endfunction
command! NewPlugin call <sid>NewPlugin()
"
" Create new vim file
function! s:NewVimFile()
  echohl String | let text = input('File name: ') | echohl None
  if text ==# '' | return | endif
  execute 'e ~/.vim/rcfiles/' . text
  execute 'set filetype=vim'
endfunction
command! NewVimFile call <sid>NewVimFile()

" Handles closing in cases where you would be the last window
function! CloseWindowOnSuccess(code) abort
  if a:code == 0
    let current_window = winnr()
    bdelete!
    " Handles special cases where window remains due startify
    if winnr() == current_window
      close
    endif
  endif
endfunction

" Open autoclosing terminal, with optional size and dir
function! OpenTerm(cmd) abort
  if has('nvim')
    call termopen(a:cmd, {'on_exit': { _, c -> CloseWindowOnSuccess(c) }})
  else
    call term_start(a:cmd, {'exit_cb': {_, c -> CloseWindowOnSuccess(c)}})
  endif
  setf openterm
endfunction

" Open vsplit with animation
function! OpenVTerm(cmd, percent) abort
  if has('nvim')
    vnew
  endif
  call OpenTerm(a:cmd)
  wincmd L | vertical resize 1
  call animate#window_percent_width(a:percent)
endfunction

function! OpenHTerm(cmd, percent) abort
  if has('nvim')
    new
  endif
  call OpenTerm(a:cmd)
  wincmd J | resize 1
  call animate#window_percent_height(a:percent)
endfunction

" vim:ft=vim

#+end_src

** general

#+begin_src vimrc :tangle ./vim/rcfiles/general
  set hidden                        " Allow buffer change w/o saving
  set autoread                      " Load file from disk, ie for git reset
  set nocompatible                  " Not concerned with vi compatibility
  set lazyredraw                    " Don't update while executing macros
  set backspace=indent,eol,start    " Sane backspace behavior
  set history=1000                  " Remember last 1000 commands
  set scrolloff=7                   " Start scrolling when we're 7 lines away from margins
  set mouse-=a
  set expandtab                     " Convert <tab> to spaces (2 or 4)
  set tabstop=2                     " Two spaces per tab as default
  set shiftwidth=2                  " Then override with per filteype
  set softtabstop=2                 " Specific settings via autocmd
  set secure                        " Limit what modelines and autocmds can do
  set autowrite                     " Write for me when I take any action
  set autoindent
  set copyindent
  set textwidth=79
  set viminfo+=!
  set rtp+=/usr/local/opt/fzf
  set cmdheight=2
  set formatoptions-=cro             " Stop vim to keep adding comments on carriage return
  set relativenumber
  set number
  set re=1
  scriptencoding utf-16             " Allow emoji in vimrc
  set nrformats+=alpha              " Force decimal-based arithmetic
  set shortmess+=c                  " don't give |ins-completion-menu| messages
  set updatetime=300                " You will have a bad experience for diagnostic messages when it's default 4000
  set signcolumn=yes                " always show signcolumns
  set shell=/bin/zsh                " Set zsh as default shell
  set showmatch                     " jump to matches when entering regexp
  set isfname-=:
  set shortmess+=c                  " Don't pass messages to |ins-completion-menu|

  set termguicolors

  if has('nvim')
    set inccommand=nosplit " substitute with preview
  endif

  " Fix netrw buffer issue
  let g:netrw_fastbrowse = 0

  " Disable sound/visual bell on errors
  " May need additional config about audible bell
  set t_vb=

  " Set modeline to 1 to allow rcfiles to be recognized as vim files
  set modelines=1

  " I save constantly and hate swap files in my prject dirs
  set nobackup
  set nowritebackup
  set noswapfile

  " Completions
  set completeopt-=menu
  set completeopt+=menuone   " Show the completions UI even with only 1 item
  set completeopt-=longest   " Don't insert the longest common text
  set completeopt-=preview   " Hide the documentation preview window
  set completeopt+=noinsert  " Don't insert text automatically
  set completeopt-=noselect  " Highlight the first completion automatically

  " Setup nice command tab completion
  set wildmenu
  set wildmode=list:longest,full
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc

  " Persistent undo
  let undodir = expand('~/.undo-vim')
  if !isdirectory(undodir)
    call mkdir(undodir)
  endif
  set undodir=~/.undo-vim
  set undofile " Create FILE.un~ files for persistent undo

  set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.

  " (Hopefully) removes the delay when hitting esc in insert mode
  " set noesckeys " do not work on neovim
  set ttimeout
  " Don't wait so long for the next keypress (particularly in ambigious Leader
  " situations.
  set timeoutlen=500

  " vim:ft=vim

#+end_src

** programming
*** languages
**** go
#+begin_src vimrc :tangle ./vim/rcfiles/go

augroup filetype_go
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd BufNewFile,BufRead *.go setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd Filetype go nmap <leader>r :GoRun <cr><Esc>
  autocmd Filetype go nmap <leader>t <Plug>(go-test)
  autocmd Filetype go nmap <leader>c <Plug>(go-coverage-toggle)
  autocmd Filetype go nmap <leader>b :<C-u>call <SID>build_go_files()<cr>
augroup END

let g:go_fmt_command = "goimports"
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_fields = 1
let g:go_highlight_types = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand("%")
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

" vim:ft=vim

#+end_src
**** haskell
#+begin_src vimrc :tangle ./vim/rcfiles/haskell

augroup filetype_haskell
  " Clear old autocmds in group
  autocmd!
  autocmd FileType haskell nnoremap <leader>hr :Dispatch runhaskell %<tab><cr>
  autocmd FileType haskell nnoremap <leader>hb :Dispatch ghc %<tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** html
#+begin_src vimrc :tangle ./vim/rcfiles/html

augroup filetype_html
  " Clear old autocmds in group
  autocmd!
  " Install Emmet
  autocmd FileType html,css EmmetInstall
augroup END

" vim:ft=vim

#+end_src
**** javascript
#+begin_src vimrc :tangle ./vim/rcfiles/javascript
" au BufRead,BufNewFile *.json set filetype=json
augroup filetype_javascript
  " Clear old autocmds in group
  autocmd!
  " Set syntax javascript to coffee script files
  autocmd FileType javascript nnoremap <leader>r :Dispatch node %<cr>
  autocmd FileType javascript.jsx set ft=javascript
augroup END

" vim:ft=vim



#+end_src
**** json

#+begin_src vimrc :tangle ./vim/rcfiles/json
augroup filetype_json
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd Filetype json nmap <leader>p :w<cr> :PrettyJSON<cr> :w<cr>
augroup END

" Requires 'jq' (brew install jq)
function! s:PrettyJSON()
  %!jq .
  set filetype=json
endfunction
command! PrettyJSON :call <sid>PrettyJSON()
" vim:ft=vim

#+end_src
**** lua
#+begin_src vimrc :tangle ./vim/rcfiles/lua

augroup filetype_lua
  " Clear old autocmds in group
  autocmd!
  autocmd FileType lua nnoremap <leader>r :Dispatch lua %<Tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** markdown
#+begin_src vimrc :tangle ./vim/rcfiles/markdown
augroup filetype_markdown_and_txt
  " Clear old autocmds in group
  autocmd!
  " By default, vim thinks .md is Modula-2.
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown
  autocmd FileType pad-notes set filetype=markdown
  " Without this, vim breaks in the middle of words when wrapping
  autocmd FileType markdown setlocal nolist wrap lbr
  " Turn on spell-checking in markdown and text.
  autocmd BufRead,BufNewFile *.md,*.txt setlocal spell
  " Don't display whitespaces
  autocmd BufNewFile,BufRead *.txt setlocal nolist
augroup END

" vim: ft=vim
#+end_src
**** python
#+begin_src vimrc :tangle ./vim/rcfiles/python

let g:python_host_prog='/usr/bin/python'
let g:python3_host_prog='/opt/homebrew/bin/python3'

augroup filetype_python
  " Clear old autocmds in group
  autocmd!
  autocmd BufNewFile,BufRead *.py setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd FileType python nnoremap <leader>py :Dispatch python3 %<Tab><cr>
  autocmd FileType python nnoremap <leader>pt :TestFile<cr>
  autocmd BufWritePre *.py :%s/\s\+$//e
augroup END
" vim:ft=vim

#+end_src
**** ruby
#+begin_src vimrc :tangle ./vim/rcfiles/ruby

let g:ruby_path = system('rvm current')
let ruby_operators = 1

augroup filetype_ruby
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd FileType rspec set filetype=ruby
  autocmd FileType ruby,eruby,yaml setlocal ai sw=2 sts=2 et
  autocmd FileType ruby,eruby,yaml setlocal path+=lib
  " Make ?s part of words
  autocmd FileType ruby,eruby,yaml setlocal iskeyword+=?
  autocmd FileType gitcommit setlocal spell textwidth=72
  " Run the current ruby file
  autocmd FileType ruby nnoremap <leader>r :Dispatch ruby %<cr>
  " Generage tags for ruby files
  autocmd FileType ruby nnoremap <Leader>rt :!ctags -R --languages=ruby --exclude=.git --exclude=log .<cr>
  " Remove trailing whitespace on save for ruby files.
  autocmd BufWritePre *.rb :%s/\s\+$//e
  autocmd BufRead,BufNewFile {Vagrantfile,Gemfile,Guardfile,Thorfile,Procfile,config.ru,*.rake,.pryrc} set filetype=ruby
  " Set .erb html files
  autocmd FileType eruby setlocal sw=2 sts=2 ts=2 " Two spaces per tab

  " Setting for vim-dispatch
  autocmd FileType ruby
        \ let b:start = executable('pry') ? 'pry -r "%:p"' : 'irb -r "%:p"' |
        \ if expand('%') =~# '_spec\.rb$' |
        \   let b:dispatch = 'rspec %' |
        \ elseif expand('%') =~# '_test\.rb$' |
        \   let b:dispatch = 'ruby -Ilib:test %' |
        \ elseif !exists('b:dispatch') |
        \   let b:dispatch = 'ruby -wc %' |
        \ endif

  " Clean comments
  autocmd FileType ruby nnoremap <leader>cc :g/#/d<cr>
  nnoremap <Leader>t :w<cr>:call RunTest('TestFile')<cr>
  nnoremap <Leader>s :call RunTest('TestNearest')<cr>
  nnoremap <Leader>a :call RunTest('TestSuite')<cr>
  nnoremap <Leader>l :call RunTest('TestLast')<cr>
  nnoremap <leader>or :tabe config/routes.rb<cr>
  nnoremap <leader>ol :tabe config/locales<cr>
augroup END

" Convert 1.8 hash syntax to 1.9 syntax
nnoremap <leader>19 :%s/:\([^ ]*\)\(\s*\)=>/\1:/gc<cr>
vnoremap <leader>19 :s/:\([^ ]*\)\(\s*\)=>/\1:/g<cr>
nnoremap <leader>18 :%s/\(\w\+\):\s/:\1 => /gc<cr>
vnoremap <leader>18 :s/\(\w\+\):\s/:\1 => /g<cr>

" vim:ft=vim
#+end_src
**** rust
#+begin_src vimrc :tangle ./vim/rcfiles/rust

augroup filetype_rust
  " Clear old autocmds in group
  autocmd!
  autocmd FileType rust nnoremap <leader>cr :Cargo run<cr>
  autocmd FileType rust nnoremap <leader>cb :Cargo build<cr>
augroup END
" vim:ft=vim
#+end_src
**** sql
#+begin_src vimrc :tangle ./vim/rcfiles/sql

augroup filetype_sql
  " Clear old autocmds in group
  autocmd!

  autocmd FileType sql call SqlFormatter()
augroup END

function SqlFormatter()
  set noai

  map ,pt :%!sqlformat --reindent --keywords upper --identifiers lower -<CR>
endfunction

" vim:ft=vim
#+end_src

*** refactoring
#+begin_src vimrc :tangle ./vim/rcfiles/refactoring
" Borrowed from Gary Bernhardt's vimrc
function! ExtractVariable()
  echohl String | let name = input("Variable name: ") | echohl None
  if name == '' | return | endif

  " Enter visual mode (input() takes us out of it)
  normal! gv

  " Replace selected text with the variable name
  exec "normal c" . name
  " Define the variable on the line above
  if &ft == "vim"
    exec "normal! Olet " . name . " = "
  elseif &ft == 'javascript'
    exec "normal! Ovar " . name . " = "
  else
    exec "normal! O" . name . " = "
  endif
  " Paste the original selected text to be the variable value
  normal! $p
  if &ft == 'javascript'
    normal! A;
  endif
endfunction
vnoremap <leader>ev :call ExtractVariable()<cr>

function! InlineVariable()
  if &filetype == 'javascript'
    s/\v^(\s+)var (.*);$/\1\2/
    nohl
  elseif &filetype == 'vim'
    s/\v^(\s+)let (.*)$/\1\2/
    nohl
  endif
  normal! ^*Ndf=x"vd$ddnviw"vp
endfunction
nnoremap <leader>ve :call InlineVariable()<cr>

" vim: ft=vim
#+end_src
** helpfiles
#+begin_src vimrc :tangle ./vim/rcfiles/helpfiles

au filetype help call HelpFileMode()

function! HelpFileMode()
  wincmd T " Maximze the help on open
  nnoremap <buffer> <tab> :call search('\|.\{-}\|', 'w')<cr>:noh<cr>2l
  nnoremap <buffer> <S-tab> F\|:call search('\|.\{-}\|', 'wb')<cr>:noh<cr>2l
  nnoremap <buffer> <cr> <c-]>
  nnoremap <buffer> <bs> <c-T>
  nnoremap <buffer> q :q<CR>
  setlocal nonumber
  setlocal nospell
endfunction

nnoremap <leader>rh :h local-additions<cr>

" vim:ft=vim

#+end_src

** mappings
#+begin_src vimrc :tangle ./vim/rcfiles/mappings

" Emacs-like mappings
nmap <C-x><C-s> :w<cr>
nmap <C-x><C-c> :x<cr>
nmap <C-s> /
" nmap <C-x>b :FzfBuffers<cr>
nmap <C-c>pf :FzfFiles<cr>
nmap <C-x>1 :only<cr>
nmap <C-x>2 :split<cr>
nmap <C-x>3 :vsplit<cr>
nmap <C-x>0 :q<cr>

nnoremap <silent> H :call <SID>show_documentation()<cr>
nnoremap <silent> K :FzfRg <C-R><C-W><cr>

function! s:show_documentation()
  if (index(['vim', 'help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

" Opens help the word under the cursor
nnoremap <leader>h :exe 'help' expand('<cword>')<cr>

" select last paste in visual mode
nnoremap gp `[v`]

" Change vertically split to horizonally
nnoremap <leader>fh <C-w>t<C-w>K

" Change horizonally split to vertically
nnoremap <leader>fv <C-w>t<C-w>H

" Make Y yank to end of line (like D, or C)
nmap Y y$

" Insert a caller into Ruby code
nnoremap <leader>wtf oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc>

" Source vimrc
nnoremap <leader>sv :source ~/.vim/vimrc<cr>

" Toggle paste mode on and off
nnoremap <leader>pp :set paste<cr>o<esc>"*]p:set nopaste<cr>

nnoremap ; :

" Indent the whole file
nnoremap <Leader>i mmgg=G`m

" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
nnoremap <space>e :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <C-x><C-f> :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <space>s :split <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>v :vsplit <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>r :r <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>t :tabe <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>sav :sav <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>

" Use j/k to start, then scroll through autocomplete options
inoremap <expr> <C-j> ((pumvisible())?("\<C-n>"):("\<C-x><c-n>"))
inoremap <expr> <C-k> ((pumvisible())?("\<C-p>"):("\<C-x><c-k>"))

" Close the quickfix window
nnoremap <space><space> :ccl<cr>

" Increase and decrease numbers
nnoremap <C-b> <C-a>

" Let's be reasonable, shall we?
nnoremap k gk
nnoremap j gj

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f')<CR>

" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace')<CR>

" Disable arrows
for prefix in ['i', 'n', 'v']
  for key in ['<Up>', '<Down>', '<Left>', '<Right>']
    exe prefix . 'noremap ' . key . " <Nop>"
  endfor
endfor

" resize panes
nnoremap <silent> <Up> :call animate#window_delta_height(15)<cr>
nnoremap <silent> <Down> :call animate#window_delta_height(-15)<cr>
nnoremap <silent> <Left> :call animate#window_delta_width(30)<cr>
nnoremap <silent> <Right> :call animate#window_delta_width(-30)<cr>

" Scroll the viewport faster
nnoremap <C-e> 7<C-e>
nnoremap <C-y> 7<C-y>
vnoremap <C-e> 7<C-e>
vnoremap <C-y> 7<C-y>

" Disable mouse scroll wheel
nnoremap <ScrollWheelUp> <nop>
nnoremap <S-ScrollWheelUp> <nop>
nnoremap <C-ScrollWheelUp> <nop>
nnoremap <ScrollWheelDown> <nop>
nnoremap <S-ScrollWheelDown> <nop>
nnoremap <C-ScrollWheelDown> <nop>
nnoremap <ScrollWheelLeft> <nop>
nnoremap <S-ScrollWheelLeft> <nop>
nnoremap <C-ScrollWheelLeft> <nop>
nnoremap <ScrollWheelRight> <nop>
nnoremap <S-ScrollWheelRight> <nop>
nnoremap <C-ScrollWheelRight> <nop>

" Open Gemfile
nnoremap <leader>og :e Gemfile<cr>

" Jump to start and end of line using the home row keys
nmap 0 ^

" Tab/shift-tab to indent/outdent in visual mode.
vnoremap <Tab> >gv
vnoremap <S-Tab> <gv

" Quickly browse to any tag/symbol in the project
nmap <leader>ot :tag<space>

" Save file as sudo
cmap w!! w !sudo tee % >/dev/null

" Move split to tab
noremap <leader>mt <c-w><s-t>

" Map to increment and decrement
nnoremap + <C-a>
nnoremap - <C-x>
xnoremap + g<C-a>
xnoremap - g<C-x>

" Open Lazygit
nnoremap <leader>tlg :call OpenHTerm('lazygit', 0.8)<cr>
" Open Lazydocker
nnoremap <leader>tld :call OpenHTerm('lazydocker', 0.8)<cr>

" Correct previous misspelled word ( Don't forgot to set spell )
nnoremap <space>sp mm[s1z=`m

"vim:ft=vim
#+end_src

** remote yank
#+begin_src vimrc :tangle ./vim/rcfiles/remote-yank

nnoremap <leader>li :call RemoteYank('i')<cr>
nnoremap <leader>la :call RemoteYank('a')<cr>
nnoremap <leader>lr :call RemoteYank('r')<cr>

function! RemoteYank(dir)
  if &relativenumber
    echom "setting number"
    let was_relative = 1
    set number
    redraw!
  endif

  echohl String | let line = input("Remote link to yank: ") | echohl None
  if line == '' | return | endif

  execute line.'yank a'
  if a:dir == 'i'
    normal "aP
  elseif a:dir == 'a'
    normal "ap
  else
    normal V"ap
  endif

  if was_relative
    set relativenumber
  endif
endfunction

" vim:ft=vim
#+end_src

** search
#+begin_src vimrc :tangle ./vim/rcfiles/search

" Searching stuff
set hlsearch                    " highlight searches, map below to clear
set incsearch                   " do incremental searching
set ignorecase                  " Case insensitive...
set smartcase                   " ...except if you use UCase

nnoremap <silent><leader><space> :nohl<cr>

" quick searching of vimrc files
function! s:VimrcSearch()
  echohl String | let text = input("Text to search: ") | echohl None
  if text == '' | return | endif
  execute "Rg ". text ." ~/.dotfiles/vim/rcfiles/* ~/.dotfiles/vim/rcplugins/*"
endfunction
command! VimrcSearch call <sid>VimrcSearch()
nnoremap <leader>sr :VimrcSearch<cr>

" Mappings for quick search & replace. Global set to default
" Do a / search first, then leave pattern empty in :s// to use previous
nnoremap <Leader>sub :%s///g<left><left>
vnoremap <Leader>sub :s///g<left><left>
nnoremap <leader>wub :%s//<C-r><C-w>/g<cr>

" Search for selected text, forwards or backwards.
" http://vim.wikia.com/wiki/Search_for_visually_selected_text
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

nnoremap Q @q
vnoremap Q :normal Q<cr>

" vim:ft=vim
#+end_src

** statusline
For general info on statusline, start with the :h, then see [[http://got-ravings.blogspot.com/2008/08/vim-pr0n-making-statuslines-that-own.html][this link]]
NOTE: NSFW, but very good overview of statusling configuration

#+begin_src vimrc :tangle ./vim/rcfiles/statusline

"Use this to prevent some settings from reloading
let g:vimrc_loaded = 1

set laststatus=2 " Always show the statusline

"define 3 custom highlight groups
hi User1 ctermbg=lightgray ctermfg=yellow guifg=orange guibg=#444444 cterm=bold gui=bold
hi User2 ctermbg=lightgray ctermfg=red guifg=#dc143c guibg=#444444 gui=none
hi User3 ctermbg=lightgray ctermfg=red guifg=#ffff00 guibg=#444444 gui=bold

set statusline= " Clear the statusline for vimrc reloads

set stl=%*                        " Normal statusline highlight
set stl^=%{coc#status()}%{get(b:,'coc_current_function','')} " coc status line
set stl+=%{fugitive#statusline()} " Current branch
set stl+=%{InsertSpace()}         " Put a leading space in

set stl+=%1*                      " Red highlight
set stl+=%{HasPaste()}            " Red show paste
set stl+=%*                       " Return to normal stl hilight

set stl+=%-40f\                   " Filename

set stl+=%2*                      " Red highlight
set stl+=%m                       " Modified flag

set stl+=%*                       " Return to normal stl hilight
set stl+=%r                       " Readonly flag
set stl+=%h                       " Help file flag

set stl+=%*                       " Set to 3rd highlight
set stl+=\ %y                     " Filetype

set stl+=%=                       " Right align from here on
set statusline+=%{SlSpace()}      " Vim-space plugin current setting
set stl+=\ \ Col:%c               " Column number
set stl+=\ \ Line:%l/%L           " Line # / total lines
set stl+=\ \ %P%{InsertSpace()}   " Single space buffer

" set stl+=%2*                    " Yello highlight
" set stl+=%*                     " Return to normal stl hilight

function! SlSpace()
  if exists("*GetSpaceMovement")
    return "[" . GetSpaceMovement() . "]"
  else
    return ""
  endif
endfunc

function! InsertSpace()
  " For adding trailing spaces onto statusline
  return ' '
endfunction

function! HasPaste()
  if &paste
    return '[PASTE]'
  else
    return ''
  endif
endfunction

function! CurDir()
  let curdir = substitute(getcwd(), '/Users/pablobfonseca/', "~/", "g")
  return curdir
endfunction

" vim:ft=vim
#+end_src

** tags
#+begin_src vimrc :tangle ./vim/rcfiles/tags

set tags^=./.git/tags

augroup tags_stuff
  " Clear old autocmds in group
  autocmd FileType * call EnableTagNavMaps()
augroup END

function! EnableTagNavMaps()
  if s:BufferIsTagNavigable()
    nmap <buffer> <bs> <c-t>
  endif
endfunction

let s:navigable_filetypes = ['vim', 'ruby', 'javascript', 'sh']

function! s:BufferIsTagNavigable()
  let is_navigable_filetype = index(s:navigable_filetypes, &filetype) != -1
  let is_normal_buffer = &buftype !=? 'nofile'
  return is_navigable_filetype && is_normal_buffer
endfunction

" Generate ctags
nnoremap <Leader>rt :!ctags --tag-relative --extras=+f -Rf .git/tags --languages=-javascript,sql<CR>

function! s:RebuildTagsFile()
  !ctags -R --exclude=coverage --exclude=files --exclude=public --exclude=log --exclude=tmp --exclude=vendor *
endfunction
command! -nargs=0 RebuildTagsFile call s:RebuildTagsFile()

" vim:ft=vim
#+end_src

** templates
#+begin_src vimrc :tangle ./vim/rcfiles/templates

if has("autocmd")
  augroup templates
    autocmd!
    autocmd BufNewFile *.sh 0r ~/.vim/templates/skeleton.sh
  augroup END
endif
" vim: ft=vim
#+end_src

** terminal
#+begin_src vimrc :tangle ./vim/rcfiles/terminal

augroup terminal
  " Clear old autocmds in group
  autocmd!

  if has('nvim')
    autocmd BufEnter * if &buftype == 'terminal' | :startinsert | endif

    " Quit term buffer with Esc
    tnoremap <silent> <Esc> <C-\><C-n><cr>

    " use alt+hjkl to move between split/vsplit panels
    tnoremap <c-h> <C-\><C-n><C-w>h
    tnoremap <c-j> <C-\><C-n><C-w>j
    tnoremap <c-k> <C-\><C-n><C-w>k
    tnoremap <c-l> <C-\><C-n><C-w>l
    function! OpenTerminal()
      split | terminal
      split term:///bin/zsh
      resize 10
    endfunction
  " Open Terminal on Ctrl+n
    nnoremap <C-x>n :call OpenTerminal()<cr>
  endif
augroup END

" vim:ft=vim
#+end_src

** vim
#+begin_src vimrc :tangle ./vim/rcfiles/vim

augroup vim_stuff
  " Clear old autocmds in group
  autocmd!
  " automatically rebalance windows on vim resize
  autocmd VimResized * :wincmd =
  " Execute the vim current vim command line
  autocmd Filetype vim nnoremap <leader>x :execute getline(".")<cr>

  " Wrap the quickfix window
  autocmd FileType qf setlocal wrap linebreak
  autocmd BufWritePre * :call s:MkNonExDir(expand('<afile>'), +expand('<abuf>'))
  autocmd BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" Functions

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
nnoremap <Leader>rr :call RenameFile()<cr>

function! CmdLine(str)
  exe "menu Foo.Bar :" . a:str
  emenu Foo.Bar
  unmenu Foo
endfunction

function! VisualSelection(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'gv'
    call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

function! s:MkNonExDir(file, buf)
  if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
    let dir=fnamemodify(a:file, ':h')
    if !isdirectory(dir)
      call mkdir(dir, 'p')
    endif
  endif
endfunction

function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
vnoremap <silent> <Leader>al :Align<CR>

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

" TODO: Create a function to search gems right from vim
function! SearchForCallSitesCursor()
  let searchTerm = expand("<cword>")
  call SearchForCallSites(searchTerm)
endfunction

" Search for call sites for term (excluding its definition) and
" load into the quickfix list.
function! SearchForCallSites(term)
  cexpr system('ag ' . shellescape(a:term) . '\| grep -v def')
endfunction

" vim:ft=vim
#+end_src

** visual
#+begin_src vimrc :tangle ./vim/rcfiles/visual

colorscheme vendetta

set visualbell

" Easy access to maximizing
nnoremap <C-_> <C-w>_

set splitbelow
set splitright

" Colors
set t_Co=256
hi Search guifg=#000000 guibg=#8dabcd guisp=#8dabcd gui=NONE ctermfg=NONE ctermbg=110 cterm=NONE
hi WarningMsg guifg=#bd4848 guibg=#f9f8ff guisp=#f9f8ff gui=bold ctermfg=131 ctermbg=15 cterm=bold
hi ErrorMsg guifg=#bd5353 guibg=NONE guisp=NONE gui=NONE ctermfg=131 ctermbg=NONE cterm=NONE

" Make it more obvious which paren I'm on
hi MatchParen cterm=none ctermbg=black ctermfg=yellow

hi! link Search CursorLine
hi! link SpellBad ErrorMsg
hi! link SpellCap ErrorMsg
hi! link Error ErrorMsg

nnoremap <leader>! :redraw!<cr>

" zoom a vim pane, <C-w>= to re-balance
nnoremap <leader>- :wincmd _<cr>:wincmd \|<cr>
nnoremap <leader>= :wincmd =<cr>

" vim:ft=vim
#+end_src

** zsh
#+begin_src vimrc :tangle ./vim/rcfiles/zsh

augroup filetype_zsh
  " Clear old autocmds in group
  autocmd!
  " set shell syntax for zsh files
  autocmd FileType zsh set syntax=sh
  autocmd BufRead,BufNewFile *.zsh-theme set filetype=zsh
augroup END

command! ReformatCurlRequest silent %s/\s\(-.\{-}\)\s/
 \1 /g

" vim:ft=vim
#+end_src
* rcplugins
** addon-mw-utils
#+begin_src vimrc :tangle ./vim/rcplugins/addon-mw-utils

Plug 'marcweber/vim-addon-mw-utils'

" vim:ft=vim
#+end_src
** ale.vim
Ale.vim - Check syntax in Vim asynchronously and fix files, with Language Server Protocol (LSP) support

#+begin_src vimrc :tangle ./vim/rcplugins/ale

Plug 'dense-analysis/ale'

let g:ale_linters = { 'javascript': ['xo'] }
let g:ale_fixers = { 'javascript': ['xo'] }

" vim:ft=vim
#+end_src
** animate.vim
A Vim Windown Animation Library

#+begin_src vimrc :tangle ./vim/rcplugins/animate

Plug 'camspiers/animate.vim'

let g:animate#easing_func = 'animate#ease_out_quad'
" vim: ft=vim
#+end_src
** bundler
Lightweight support for Ruby's Bundler

#+begin_src vimrc :tangle ./vim/rcplugins/bundler

" Plug 'tpope/vim-bundler', { 'for': 'ruby' }

" vim: ft=vim
#+end_src
** coc
Intellisense engine for vim8

#+begin_src vimrc :tangle ./vim/rcplugins/coc

Plug 'neoclide/coc.nvim', {'branch': 'release'}

let g:coc_global_extensions = [
      \ 'coc-snippets',
      \ 'coc-pairs',
      \ 'coc-emmet',
      \ 'coc-tsserver',
      \ 'coc-json',
      \ 'coc-solargraph',
      \ 'coc-css',
      \ 'coc-python'
      \ ]

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Use <c-space> to trigger completion
" inoremap <silent><expr> <c-space> coc#refresh()
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<cr>"

inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Rename current word
nmap <F2> <Plug>(coc-rename)

" vim: ft=vim
#+end_src
** coc-neco
viml completion source for coc.nvim

#+begin_src vimrc :tangle ./vim/rcplugins/coc-neco

Plug 'neoclide/coc-neco'
" vim: ft=vim
#+end_src
** commentary
Motion aware commenting

#+begin_src vimrc :tangle ./vim/rcplugins/commentary

Plug 'tpope/vim-commentary'

  vmap cm <Plug>Commentary
  vmap <M-/> <Plug>Commentary
  nmap cm <Plug>Commentary
  nmap cml <Plug>CommentaryLine
  nmap <M-/> <Plug>CommentaryLine
  " vim:ft=vim
#+end_src

** easy-align
A Vim alignment plugin

#+begin_src vimrc :tangle ./vim/rcplugins/easy-align

Plug 'junegunn/vim-easy-align'

vmap <leader>ea <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" vim:ft=vim
#+end_src
** easymotion
Vim motions on speed

#+begin_src vimrc :tangle ./vim/rcplugins/easymotion

Plug 'easymotion/vim-easymotion'

let g:EasyMotion_leader_key = '<leader><leader>'

" vim:ft=vim
#+end_src
** emmet
Text expansion for html markup

#+begin_src vimrc :tangle ./vim/rcplugins/emmet

Plug 'mattn/emmet-vim',

let g:user_emmet_leader_key='<C-Z>'
let g:user_emmet_settings = {
      \ 'javascript.jsx' : {
      \   'extends': 'jsx',
      \},
    \}
let g:user_emmet_mode='a'

" vim:ft=vim
#+end_src
** endwise
Intelligently insert ends, endifs, etc

#+begin_src vimrc :tangle ./vim/rcplugins/endwise

Plug 'tpope/vim-endwise'

" vim:ft=vim
#+end_src
** fugitive
Interact with git via Vim

#+begin_src vimrc :tangle ./vim/rcplugins/fugitive

Plug 'tpope/vim-fugitive'

nmap <leader>st :call <sid>SaveSessionAndShowGitStatus()<cr>
nmap <leader>ST :call <sid>RestoreSession()<cr>
nmap <leader>gd :Gdiff<cr>
nmap <leader>gb :Gblame<CR>

function! s:SaveSessionAndShowGitStatus()
  let session_name = split(getcwd(), "/")[-1]
  execute "silent! mksession! ~/.vim/sessions/" . session_name
  silent tabonly | silent only | Gstatus
endfunction

function! s:RestoreSession()
  let session_name = split(getcwd(), "/")[-1]
  execute "source ~/.vim/sessions/" . session_name
endfunction

set diffopt+=vertical

augroup git_stuff
  " Clear old autocmds in group
  autocmd!
  autocmd FileType gitcommit setl spell
  autocmd FileType gitcommit setl diffopt+=vertical
  autocmd FileType gitcommit nmap <buffer> <S-Tab> <C-p>
  autocmd FileType gitcommit nmap <buffer> <Tab> <C-n>
  autocmd BufRead,BufNewFile */.git/COMMIT_EDITMSG wincmd _
  autocmd BufEnter PULLREQ_EDITMSG setlocal filetype=gitcommit
augroup END

command! GitDiff call s:GitDiff()

" vim:ft=vim
#+end_src
** fzf.vim
#+begin_src vimrc :tangle ./vim/rcplugins/fzf

"Plug '/usr/local/opt/fzf'
"Plug 'junegunn/fzf.vim'

"let g:fzf_command_prefix = 'Fzf'

"" Configure FZF to use a floating window configuration
"let $FZF_DEFAULT_OPTS = '--layout=reverse'

"if has('nvim')
"  let $FZF_DEFAULT_OPTS .= ' --inline-info'
"endif

"let g:fzf_colors =
"\ { 'fg':      ['fg', 'Normal'],
"  \ 'bg':      ['bg', 'Normal'],
"  \ 'hl':      ['fg', 'Comment'],
"  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
"  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
"  \ 'hl+':     ['fg', 'Statement'],
"  \ 'info':    ['fg', 'PreProc'],
"  \ 'border':  ['fg', 'Ignore'],
"  \ 'prompt':  ['fg', 'Conditional'],
"  \ 'pointer': ['fg', 'Exception'],
"  \ 'marker':  ['fg', 'Keyword'],
"  \ 'spinner': ['fg', 'Label'],
"  \ 'header':  ['fg', 'Comment'] }

"autocmd! FileType fzf
"autocmd FileType fzf set noshowmode noruler nonu

"nnoremap <leader>f :Find<cr>
"nnoremap <C-p> :AF<cr>
"nnoremap <C-f> :FzfGitFiles<cr>
"nnoremap <leader>gc :FzfFiles app/controllers<cr>
"nnoremap <leader>gj :FzfFiles app/assets/javascripts<cr>
"nnoremap <leader>gl :FzfFiles config/locales<cr>
"nnoremap <leader>gm :FzfFiles app/models<cr>
"nnoremap <leader>gs :FzfFiles spec<cr>
"nnoremap <leader>gv :FzfFiles app/views<cr>
"nnoremap <leader>gw :FzfFiles app/workers<cr>
"nnoremap <leader>gh :FzfFiles app/helpers<cr>
"nnoremap <leader>gsv :FzfFiles app/services<cr>
"nnoremap <leader>gpr :FzfFiles app/presenters<cr>
"nnoremap <leader>gy :FzfFiles app/assets/stylesheets<cr>
"nnoremap <leader>gf :FzfFiles spec/factories<cr>

"nnoremap <leader>rf :FzfFiles ~/.vim/rcfiles<cr>
"nnoremap <leader>rp :FzfFiles ~/.vim/rcplugins<cr>
"nnoremap <leader>df :FzfFiles ~/.dotfiles<cr>
"nnoremap <leader>fb :FzfBuffers<cr>
"nnoremap <leader>ft :FzfTags<cr>
"nnoremap <leader>fm :FzfMaps<cr>
"nnoremap <leader>fc :FzfCommits<cr>
"nnoremap gs :FzfGFiles?<cr>
"nnoremap <leader>bl :FzfBLines<cr>
"nnoremap <leader>fh :FzfHelpTags<cr>
"nnoremap <leader>fa :FzfAg<cr>

"imap <c-x><c-f> <plug>(fzf-complete-path)
"imap <c-x><c-k> <plug>(fzf-complete-word)
"imap <c-x><c-j> <plug>(fzf-complete-file-ag)
"imap <c-x><c-l> <plug>(fzf-complete-line)

"" Configures ripgrep with fzf
"" command! -bang -nargs=* FzfRg call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, {'options': '--delimiter : --nth 4..'}, <bang>0)
"" command! -bang -nargs=* Rgg call fzf#vim#grep("rg --no-ignore --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, {'options': '--delimiter : --nth 4..'}, <bang>0)

"" Augmenting Ag command using fzf#vim#with_preview function
""   * fzf#vim#with_preview([[options], preview window, [toggle keys...]])
""   * Preview script requires Ruby
""   * Install Highlight or CodeRay to enable syntax highlighting
""
""   :FzfAg  - Start fzf with hidden preview window that can be enabled with "?" key
""   :FzfAg! - Start fzf in fullscreen and display the preview window above
"command! -bang -nargs=* FzfAg
"      \ call fzf#vim#ag(<q-args>,
"      \                 <bang>0 ? fzf#vim#with_preview('up:60%')
"      \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
"      \                 <bang>0)

"" --column: Show column number
"" --line-number: Show line number
"" --no-heading: Do not show file headings in results
"" --fixed-strings: Search term as a literal string
"" --ignore-case: Case insensitive search
"" --no-ignore: Do not respect .gitignore, etc...
"" --hidden: Search hidden files and folders
"" --follow: Follow symlinks
"" --glob: Additional conditions for search (in this case ignore everything in the .git/ folder)
"" --color: Search color options
"command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>), 1, <bang>0)

"command! -bang -nargs=? -complete=dir FzfFiles
"      \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

"" All files
"command! -nargs=? -complete=dir AF
"      \ call fzf#run(fzf#wrap(fzf#vim#with_preview({
"      \ 'source': 'fd --type f --hidden --follow --exclude .git --no-ignore . '.expand(<q-args>)
"      \ })))
"nnoremap <leader>af :AF<cr>

"command! -bang -nargs=* GGrep
"      \ call fzf#vim#grep(
"      \   'git grep --line-number '.shellescape(<q-args>), 0,
"      \   fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)

" vim: ft=vim
#+end_src
** git-gutter
Shows a git diff in the gutter (sign column) " and stages/undoes hunks.

#+begin_src vimrc :tangle ./vim/rcplugins/git-gutter

Plug 'airblade/vim-gitgutter'

" Use fontawesome icons as signs
let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '~'
let g:gitgutter_sign_removed = '-'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed = '<'

nnoremap <leader>hv <Plug>GitGutterPreviewHunk

" vim:ft=vim
#+end_src
** go
Go development plugin for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/go

Plug 'fatih/vim-go', { 'for': 'go' }
" vim:ft=vim
#+end_src
** html5
Filetype settings for html5

#+begin_src vimrc :tangle ./vim/rcplugins/html5

Plug 'othree/html5.vim', { 'for': 'html' }

" vim:ft=vim
#+end_src
** json
Syntax highlighting for JSON

#+begin_src vimrc :tangle ./vim/rcplugins/json

" Fancy tricks with hiding quotes around attributes, includes ftdetect
Plug 'elzr/vim-json', {'for': 'json'}

let g:vim_json_syntax_conceal = 0

" vim:ft=vim
#+end_src
** lexima
Auto close parens, quotes, brackets, etc

#+begin_src vimrc :tangle ./vim/rcplugins/lexima

Plug 'cohama/lexima.vim'

" vim:ft=vim
#+end_src
** lsp
#+begin_src vimrc :tangle ./vim/rcplugins/lsp

Plug 'neovim/nvim-lspconfig'
Plug 'hrsh7th/nvim-compe'

" nnoremap <silent> gd <cmd>lua vim.lsp.buf.definition()<CR>
" nnoremap <silent> gD <cmd>lua vim.lsp.buf.declaration()<CR>
" nnoremap <silent> gr <cmd>lua vim.lsp.buf.references()<CR>
" nnoremap <silent> gi <cmd>lua vim.lsp.buf.implementation()<CR>
" nnoremap <silent> K <cmd>lua vim.lsp.buf.hover()<CR>
" nnoremap <silent> <C-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
" nnoremap <silent> <C-n> <cmd>lua vim.lsp.diagnostic.goto_prev()<CR>
" nnoremap <silent> <C-p> <cmd>lua vim.lsp.diagnostic.goto_next()<CR>

" autocmd BufWritePre *.js lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.jsx lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.py lua vim.lsp.buf.formatting_sync(nil, 100)
" autocmd BufWritePre *.rb lua vim.lsp.buf.formatting_sync(nil, 100)
" vim: ft=vim
#+end_src
** markdown
Syntax file for Markdowm files

#+begin_src vimrc :tangle ./vim/rcplugins/markdown

Plug 'tpope/vim-markdown', {'for': 'markdown'}

let g:markdown_fenced_languages = ['python', 'javascript', 'ruby', 'sh', 'yaml', 'javascript', 'go', 'html', 'vim', 'json', 'diff']

" vim:ft=vim
#+end_src
** matchit
Extended % open close pair matching

#+begin_src vimrc :tangle ./vim/rcplugins/matchit

Plug 'vim-scripts/matchit.zip'

" vim:ft=vim
#+end_src
** moonscript-vim
MoonScript support for vim

#+begin_src vimrc :tangle ./vim/rcplugins/moonscript-vim

Plug 'leafo/moonscript-vim', { 'for': 'moonscript' }
" vim: ft=vim
#+end_src
** neco-vim
The vim source for neocomplete/deoplete

#+begin_src vimrc :tangle ./vim/rcplugins/neco-vim

Plug 'Shougo/neco-vim'
" vim: ft=vim
#+end_src
** neoterm
Wrapper of some vim/neovim's :terminal functions

#+begin_src vimrc :tangle ./vim/rcplugins/neoterm

Plug 'kassio/neoterm'

nnoremap <leader>ro :Topen<cr>
" vim: ft=vim
#+end_src
** perl
Edit Perl scripts in Vim/gVim. Insert code snippets, run, check, and profile the code and look up help.

#+begin_src vimrc :tangle ./vim/rcplugins/perl

Plug 'wolfgangmehner/perl-support', { 'for': 'perl' }
" vim: ft=vim
#+end_src
** rails
Help for working with Rails projects in vim

#+begin_src vimrc :tangle ./vim/rcplugins/rails

Plug 'tpope/vim-rails'

nnoremap <leader>rs :Server<cr>
nnoremap <leader>rc :Console<cr>

let g:rails_projections = {
      \ 'app/services/*.rb': {
      \   'command': 'service',
      \ },
      \ 'app/mappers/*.rb': {'command': 'mapper'}}

" vim:ft=vim
#+end_src
** rake
it's like rails.vim without the rails

#+begin_src vimrc :tangle ./vim/rcplugins/rake

Plug 'tpope/vim-rake'

" vim: ft=vim
#+end_src
** ruby
#+begin_src vimrc :tangle ./vim/rcplugins/ruby

Plug 'vim-ruby/vim-ruby', {'for': 'ruby'}

" vim:ft=vim
#+end_src
** rust
Vim configuration for Rust

#+begin_src vimrc :tangle ./vim/rcplugins/rust

Plug 'rust-lang/rust.vim', {'for': 'rust'}
" vim: ft=vim
#+end_src
** slim
Syntax highlighting for VIM

#+begin_src vimrc :tangle ./vim/rcplugins/slim

Plug 'slim-template/vim-slim', { 'for': 'slim' }
" vim: ft=vim
#+end_src
** splitjoin
Switch between single-line and multiline forms of code

#+begin_src vimrc :tangle ./vim/rcplugins/splitjoin

Plug 'AndrewRadev/splitjoin.vim', { 'branch': 'main' }
" vim: ft=vim
#+end_src
** surround
Add, update, remove enclosing marks, ie [], {}. (), "", ''

#+begin_src vimrc :tangle ./vim/rcplugins/surround

Plug 'tpope/vim-surround'

let [s:single_quote, s:double_quote, s:no_match] = [1,2,0]
function! SurroundRequote()
    let matched_quote = s:no_match
    let [column, line] = [virtcol('.'), getline('.')]
    let offset = 1
    while offset < 30
        let matched_quote = s:QuoteStyle(line, column, offset)
        if matched_quote
            call s:SwapSurroundingQuotes(matched_quote)
            break
        endif
        let offset += 1
    endwhile
endfunction

function! s:SwapSurroundingQuotes(current_quote)
    if a:current_quote != s:single_quote && a:current_quote != s:double_quote
        return
    endif
    call s:CacheCursorLocation()
    let quote_sequence = a:current_quote == s:single_quote ? "'\"" : "\"'"
    execute "normal cs" . quote_sequence
    call s:RestoreCursorLocation()
endfunction

function! s:QuoteStyle(line, column, offset)
    let left_character = a:line[a:column - a:offset - 1]
    let right_character = a:line[a:column + a:offset - 1]
    if left_character == "'" || right_character == "'"
        return s:single_quote
    elseif left_character == '"' || right_character == '"'
        return s:double_quote
    endif
    return s:no_match
endfunction

function! s:CacheCursorLocation()
    execute "normal mm"
endfunction

function! s:RestoreCursorLocation()
    execute "normal `m"
endfunction

nmap <leader>c' :call SurroundRequote()<cr>

nmap <leader>qw ysiw"
nmap <leader>QW ysiW"

" vim:ft=vim
#+end_src
** telescope
Find, Filter, Preview, Pick. All lua, all the time.

#+begin_src vimrc :tangle ./vim/rcplugins/telescope
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plug 'nvim-telescope/telescope-fzf-native.nvim', { 'do': 'make' }
Plug 'kyazdani42/nvim-web-devicons'

nnoremap <C-p> <cmd>Telescope find_files<cr>
nnoremap <leader>f <cmd>Telescope live_grep<cr>
nnoremap <C-x>b <cmd>Telescope buffers<cr>
nnoremap gs <cmd>Telescope git_status<cr>

" vim: ft=vim
#+end_src
** textobj-word-column
Adds text-objects for word-based columns in Vim.

#+begin_src vimrc :tangle ./vim/rcplugins/textobj-word-column

Plug 'coderifous/textobj-word-column.vim'

" vim:ft=vim
#+end_src
** typescript
Typescript syntax files for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/typescript

Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }

let g:typescript_compiler_binary='tsc'
" vim: ft=vim
#+end_src
** unimpaired
Pairs of handy bracket mappings

#+begin_src vimrc :tangle ./vim/rcplugins/unimpaired

Plug 'tpope/vim-unimpaired'

" vim:ft=vim
#+end_src
** vim-dispatch
Asynchronous build and test dispatcher

#+begin_src vimrc :tangle ./vim/rcplugins/vim-dispatch

Plug 'tpope/vim-dispatch'

nnoremap d<cr> :Dispatch<space>
nnoremap <leader>co :Copen<cr>
nnoremap <leader>cop :Copen!<cr>
" vim: ft=vim
#+end_src
** vim-elm
Elm plugin for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-elm

Plug 'Zaptic/elm-vim', {'for': 'elm'}
" vim: ft=vim
#+end_src
** vim-javascript
Vastly improved Javascript indentation and syntax support in Vim.

#+begin_src vimrc :tangle ./vim/rcplugins/vim-javascript

Plug 'pangloss/vim-javascript', {'for': ['javascript', 'html']}

let g:javascript_plugin_jsdoc = 1
let g:javascript_plugin_flow = 1
" vim: ft=vim
#+end_src
** vim-jsx
React JSX syntax highlighting and indenting for vim.

#+begin_src vimrc :tangle ./vim/rcplugins/vim-jsx

Plug 'mxw/vim-jsx'
" vim: ft=vim
#+end_src
** vim-jsx-typescript
React JSX syntax highlighting for vim and Typescript

#+begin_src vimrc :tangle ./vim/rcplugins/vim-jsx-typescript

Plug 'peitalin/vim-jsx-typescript', {'for': 'tsx'}
" vim: ft=vim
#+end_src
** vim-peekaboo
Extends `"` and `@` so you can see the contents of registers

#+begin_src vimrc :tangle ./vim/rcplugins/vim-peekaboo

Plug 'junegunn/vim-peekaboo'
" vim: ft=vim
#+end_src
** vim-polyglot
A solid language pack for Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-polyglot

Plug 'sheerun/vim-polyglot'
" vim: ft=vim
#+end_src
** vim-projectionist
Granular project configuration

#+begin_src vimrc :tangle ./vim/rcplugins/vim-projectionist

Plug 'tpope/vim-projectionist'
" vim:ft=vim
#+end_src
** vim-reek
Code smell detector for Ruby in Vim

#+begin_src vimrc :tangle ./vim/rcplugins/vim-reek

Plug 'rainerborene/vim-reek', { 'for': 'ruby' }
let g:reek_on_loading = 0
let g:reek_always_show = 0
" vim: ft=vim
#+end_src
** vim-repeat
Enable repeating supported plugin maps with "."

#+begin_src vimrc :tangle ./vim/rcplugins/vim-repeat

Plug 'tpope/vim-repeat'

" vim: ft=vim
#+end_src
** vim-ripgrep
Use RipGrep in Vim and display results in a quickfix list

#+begin_src vimrc :tangle ./vim/rcplugins/vim-ripgrep

Plug 'jremmen/vim-ripgrep'

" Allow Ripgrep to work with quick list
command! -nargs=* -complete=file Ripgrep :call s:Rg(<q-args>)>
command! -nargs=* -complete=file Rg :call s:Rg(<q-args>)
" vim: ft=vim
#+end_src
** vim-rsi
Readline style insertion

#+begin_src vimrc :tangle ./vim/rcplugins/vim-rsi

Plug 'tpope/vim-rsi'

" vim:ft=vim
#+end_src
** vim-test
Run your tests at the speed of thought

#+begin_src vimrc :tangle ./vim/rcplugins/vim-test

Plug 'janko-m/vim-test'

let test#strategy = 'neoterm'

function! RunTest(cmd)
  call meoterm#open() " Opens the neoterm window
  call neoterm#normal('G') " Scroll to the end of the neoterm window
  exec a:cmd
endfunction
" vim: ft=vim
#+end_src
** vim-visual-multi
Multiple cursors plugin for vim/neovim
#+begin_src vimrc :tangle ./vim/rcplugins/vim-visual-multi

Plug 'mg979/vim-visual-multi'
" vim: ft=vim
#+end_src
** vim-xo
Vim plugin for XO

#+begin_src vimrc :tangle ./vim/rcplugins/vim-xo

Plug 'xojs/vim-xo', { 'branch': 'main' }
" vim: ft=vim
#+end_src
** webapi
#+begin_src vimrc :tangle ./vim/rcplugins/webapi

Plug 'mattn/webapi-vim'

" vim:ft=vim
#+end_src
** xml
Handles xml files

#+begin_src vimrc :tangle ./vim/rcplugins/xml

augroup filetype_ruby
  autocmd BufWritePre * filetype xml :PrettyXML()
augroup END

function! s:PrettyXML()
  %!xmllint --format -
  set filetype=xml
endfunction
command! PrettyXML :call <sid>PrettyXML()
" vim: ft=vim
#+end_src

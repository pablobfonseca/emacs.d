#+TITLE: @pablobfonseca's VIM Configuration
#+PROPERTY: header-args:vimrc :tangle ./vim/vimrc :mkdirp yes

* Welcome to my Vim config
This file generates [[file:vimrc][vimrc]] file which can be loaded by VIM at startup.
#+begin_src vimrc
"
"        _
" __   _(_)_ __ ___
" \ \ / / | '_ ` _ \
"  \ V /| | | | | | |
"   \_/ |_|_| |_| |_|
"
" File: vimrc
" Author: Pablo Fonseca <pablofonseca777@gmail.com>
" Description: VIM Rocks!
" Source: http://github.com/pablobfonseca/dotfiles
#+end_src

* Setup
#+begin_src vimrc
  let mapleader=","
  let maplocalleader="-"

  filetype off
  filetype plugin indent on

  autocmd!
  set nocompatible
#+end_src
** SourceConfigFilesIn directory


The ~SourceConfigFilesIn~ function takes a directory and eval the files inside that directory
#+begin_src vimrc
function! s:SourceConfigFilesIn(directory)
  let directory_splat = '~/.vim/' . a:directory . '/*'
  for config_file in split(glob(directory_splat), '\n')
    if filereadable(config_file)
      execute 'source' config_file
    endif
  endfor
endfunction
#+end_src
** Plugin Setup

Setup Plug to manage my plugins

Plugins are each listed in their own file. Loop and source them using the ~SourceConfigFilesIn~
#+begin_src vimrc
call plug#begin('~/.vim/plugged')

call s:SourceConfigFilesIn('rcplugins')

call plug#end()
#+end_src
* rcfiles
Vimrc is split accross multiple files, so loop over and source each

#+begin_src vimrc
call s:SourceConfigFilesIn('rcfiles')"
#+end_src

** background-command
#+begin_src vimrc :tangle ./vim/rcfiles/background-command

" This callback will be executed when the entire command is completed
function! BackgroundCommandClose(channel)
  " Read the output from the command into the quickfix window
  execute "cfile! " . g:backgroundCommandOutput
  " Open the quickfix window
  copen
  unlet g:backgroundCommandOutput
endfunction

function! RunBackgroundCommand(command)
  " Make sure we're running VIM version 8 or higher.
  if v:version < 800
    echoerr 'RunBackgroundCommand requires VIM version 8 or higher'
    return
  endif

  if exists('g:backgroundCommandOutput')
    echo 'Already running task in background'
  else
    echo 'Running task in background'
    " Launch the job.
    " Notice that we're only capturing out, and not err here. This is because, for some reason, the callback
    " will not actually get hit if we write err out to the same file. Not sure if I'm doing this wrong or?
    let g:backgroundCommandOutput = tempname()
    call job_start(a:command, {'close_cb': 'BackgroundCommandClose', 'out_io': 'file', 'out_name': g:backgroundCommandOutput})
  endif
endfunction

" So we can use :BackgroundCommand to call our function.
command! -nargs=+ -complete=shellcmd RunBackgroundCommand call RunBackgroundCommand(<q-args>)

nnoremap <leader>bc :RunBackgroundCommand

" vim: ft=vim
#+end_src

** chrome
#+begin_src vimrc :tangle ./vim/rcfiles/chrome

" Chrome Cli bindings
function! s:HasFile()
  return expand("%") != ""
endfunction

function! s:OpenTab(reload, detached)
  let open_tab_command = "open-tab"
  if s:HasFile()
    update
  endif

  if a:reload
    let open_tab_command .= " --reload"
  endif

  if a:detached
    let open_tab_command .= " --detached"
  endif

  if exists("g:app_url")
    let open_tab_command .= " " . g:app_url
  endif
  call system(open_tab_command)
endfunction

command! OpenAndReloadTab call <sid>OpenTab(1, 0)
command! OpenTab call <sid>OpenTab(0, 0)
command! OpenTabDetached call <sid>OpenTab(0, 1)
nnoremap gl <silent> :OpenAndReloadTab<cr>
nnoremap gL <silent> :OpenTabDetached<cr>

nnoremap <leader>gr :!chrome-cli reload<cr><cr>
" vim: ft=vim
#+end_src
** command line
#+begin_src vimrc :tangle ./vim/rcfiles/command-line
cnoremap <C-k> <up>
cnoremap <C-j> <down>

cnoremap <C-x><C-e> <C-e><C-f>

cnoremap %% <C-R>=expand('%:h').'/'<cr>

" vim:ft=vim
#+end_src

** folding
#+begin_src vimrc :tangle ./vim/rcfiles/folding

"Enable indent folding
set foldenable
set foldmethod=indent
set foldlevel=999

" Quick fold to level 1, especially useful for Coffeescript class files
nmap <leader>fld :set foldlevel=1<cr>

"Maps for folding, unfolding all
nnoremap <leader>fu zM<CR>
nnoremap <leader>uf zR<CR>

"Maps for setting foldleve
nnoremap <leader>fl1 :set foldlevel=1<cr>
nnoremap <leader>fl2 :set foldlevel=2<cr>
nnoremap <leader>fl3 :set foldlevel=3<cr>
nnoremap <leader>fl4 :set foldlevel=4<cr>

" Focus the current fold by closing all others
nnoremap <leader>flf mzzM`zzv

" Set foldlevel to match current line
nnoremap <leader>flc :execute 'set foldlevel=' . foldlevel('.')<cr>

" vim:ft=vim
#+end_src

** functional
Functional vimscript helpers
Taken from [[ http://learnvimscriptthehardway.stevelosh.com/chapters/39.html][here]]

#+begin_src vimrc :tangle ./vim/rcfiles/functional

function! Sorted(l)
    let new_list = deepcopy(a:l)
    call sort(new_list)
    return new_list
endfunction

function! Reversed(l)
    let new_list = deepcopy(a:l)
    call reverse(new_list)
    return new_list
endfunction

function! Append(l, val)
    let new_list = deepcopy(a:l)
    call add(new_list, a:val)
    return new_list
endfunction

function! Assoc(l, i, val)
    let new_list = deepcopy(a:l)
    let new_list[a:i] = a:val
    return new_list
endfunction

function! Pop(l, i)
    let new_list = deepcopy(a:l)
    call remove(new_list, a:i)
    return new_list
endfunction

function! Mapped(list, fn)
    let new_list = deepcopy(a:list)
    let FuncRef = function(a:fn)
    call map(new_list, string(FuncRef) . '(v:val)')
    return new_list
endfunction

function! NewFZFWindow() abort
  new | wincmd J | resize 1
endfunction

" Creates a floating window with a most recent buffer to be used
function! CreateCenteredFloatingWindow()
  if has('nvim')
    let width = float2nr(&columns * 0.8)
    let height = float2nr(&lines * 0.8)
    let top = ((&lines - height) / 2) - 1
    let left = (&columns - width) / 2
    let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

    let top = '╭' . repeat('─', width - 2) . '╮'
    let mid = '│' . repeat(' ', width - 2) . '│'
    let bot = '╰' . repeat('─', width - 2) . '╯'
    let lines = [top] + repeat([mid], height - 2) + [bot]
    let s:buf = nvim_create_buf(v:false, v:true)
    call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
    call nvim_open_win(s:buf, v:true, opts)
    set winhl=Normal:Floating
    let opts.row += 1
    let opts.height -= 2
    let opts.col += 2
    let opts.width -= 4
    call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
    autocmd BufWipeout <buffer> call CleanupBuffer(s:buf)
    tnoremap <buffer> <silent> <Esc> <C-\><C-n><CR>:call DeleteUnlistedBuffers()<CR>
  endif
endfunction

function! OnTermExit(job_id, code, event) dict
  if has('nvim')
    if a:code == 0
      call DeleteUnlistedBuffers()
    endif
  endif
endfunction

function! DeleteUnlistedBuffers()
  if has('nvim')
    for n in nvim_list_bufs()
      if ! buflisted(n)
        let name = bufname(n)
        if name == '[Scratch]' ||
              \ matchend(name, ':bash') ||
              \ matchend(name, ':fish')
          call CleanupBuffer(n)
        endif
      endif
    endfor
  endif
endfunction

function! CleanupBuffer(buf)
  if has('nvim')
    if bufexists(a:buf)
      silent execute 'bwipeout! '.a:buf
    endif
  endif
endfunction

function! ToggleTerm(cmd)
  if has('nvim')
    if empty(bufname(a:cmd))
      call CreateCenteredFloatingWindow()
      call termopen(a:cmd, { 'on_exit': function('OnTermExit') })
    else
      call DeleteUnlistedBuffers()
    endif
  endif
endfunction

function! ToggleScratchTerm()
  if has('nvim')
    call ToggleTerm('fish')
  endif
endfunction
command! ToggleScratchTerm call ToggleScratchTerm()

" When term starts, auto go into insert mode
if has('nvim')
  autocmd TermOpen * startinsert

  " Turn off line numbers etc
  autocmd TermOpen * setlocal listchars= nonumber norelativenumber
endif

" Remove current file - Extracted from tpope's vim-eunuch plugin
command! -bar -bang Remove
      \ let s:file = fnamemodify(bufname(<q-args>),':p') |
      \ execute 'bdelete<bang>' |
      \ if !bufloaded(s:file) && delete(s:file) |
      \   echoerr 'Failed to delete "'.s:file.'"' |
      \ endif |
      \ unlet s:file

" Create new plugin file
function! s:NewPlugin()
  echohl String | let text = input('Plugin name: ') | echohl None
  if text ==# '' | return | endif
  execute 'e ~/.vim/rcplugins/' . text
  execute 'set filetype=vim'
endfunction
command! NewPlugin call <sid>NewPlugin()
"
" Create new vim file
function! s:NewVimFile()
  echohl String | let text = input('File name: ') | echohl None
  if text ==# '' | return | endif
  execute 'e ~/.vim/rcfiles/' . text
  execute 'set filetype=vim'
endfunction
command! NewVimFile call <sid>NewVimFile()

" Handles closing in cases where you would be the last window
function! CloseWindowOnSuccess(code) abort
  if a:code == 0
    let current_window = winnr()
    bdelete!
    " Handles special cases where window remains due startify
    if winnr() == current_window
      close
    endif
  endif
endfunction

" Open autoclosing terminal, with optional size and dir
function! OpenTerm(cmd) abort
  if has('nvim')
    call termopen(a:cmd, {'on_exit': { _, c -> CloseWindowOnSuccess(c) }})
  else
    call term_start(a:cmd, {'exit_cb': {_, c -> CloseWindowOnSuccess(c)}})
  endif
  setf openterm
endfunction

" Open vsplit with animation
function! OpenVTerm(cmd, percent) abort
  if has('nvim')
    vnew
  endif
  call OpenTerm(a:cmd)
  wincmd L | vertical resize 1
  call animate#window_percent_width(a:percent)
endfunction

function! OpenHTerm(cmd, percent) abort
  if has('nvim')
    new
  endif
  call OpenTerm(a:cmd)
  wincmd J | resize 1
  call animate#window_percent_height(a:percent)
endfunction

" vim:ft=vim

#+end_src

** general

#+begin_src vimrc :tangle ./vim/rcfiles/general

set hidden                        " Allow buffer change w/o saving
set autoread                      " Load file from disk, ie for git reset
set nocompatible                  " Not concerned with vi compatibility
set lazyredraw                    " Don't update while executing macros
set backspace=indent,eol,start    " Sane backspace behavior
set history=1000                  " Remember last 1000 commands
set scrolloff=7                   " Start scrolling when we're 7 lines away from margins
set mouse-=a
set expandtab                     " Convert <tab> to spaces (2 or 4)
set tabstop=2                     " Two spaces per tab as default
set shiftwidth=2                  " Then override with per filteype
set softtabstop=2                 " Specific settings via autocmd
set secure                        " Limit what modelines and autocmds can do
set autowrite                     " Write for me when I take any action
set autoindent
set copyindent
set textwidth=79
set viminfo+=!
set rtp+=/usr/local/opt/fzf
set cmdheight=2
set formatoptions-=cro             " Stop vim to keep adding comments on carriage return
set relativenumber
set number
set re=1
scriptencoding utf-16             " Allow emoji in vimrc
set nrformats+=alpha              " Force decimal-based arithmetic
set shortmess+=c                  " don't give |ins-completion-menu| messages
set updatetime=300                " You will have a bad experience for diagnostic messages when it's default 4000
set signcolumn=yes                " always show signcolumns
set shell=/usr/local/bin/fish     " Set fish as default shell
set showmatch                     " jump to matches when entering regexp
set isfname-=:
set shortmess+=c                  " Don't pass messages to |ins-completion-menu|

set termguicolors

if has('nvim')
  set inccommand=nosplit " substitute with preview
endif

" Fix netrw buffer issue
let g:netrw_fastbrowse = 0

" Disable sound/visual bell on errors
" May need additional config about audible bell
set t_vb=

" Set modeline to 1 to allow rcfiles to be recognized as vim files
set modelines=1

" I save constantly and hate swap files in my prject dirs
set nobackup
set nowritebackup
set noswapfile

" Completions
set completeopt-=menu
set completeopt+=menuone   " Show the completions UI even with only 1 item
set completeopt-=longest   " Don't insert the longest common text
set completeopt-=preview   " Hide the documentation preview window
set completeopt+=noinsert  " Don't insert text automatically
set completeopt-=noselect  " Highlight the first completion automatically

" Setup nice command tab completion
set wildmenu
set wildmode=list:longest,full
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc

" Persistent undo
let undodir = expand('~/.undo-vim')
if !isdirectory(undodir)
  call mkdir(undodir)
endif
set undodir=~/.undo-vim
set undofile " Create FILE.un~ files for persistent undo

set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.

" (Hopefully) removes the delay when hitting esc in insert mode
" set noesckeys " do not work on neovim
set ttimeout
" Don't wait so long for the next keypress (particularly in ambigious Leader
" situations.
set timeoutlen=500

" vim:ft=vim

#+end_src

** programming
*** languages
**** go
#+begin_src vimrc :tangle ./vim/rcfiles/go

augroup filetype_go
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd BufNewFile,BufRead *.go setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd Filetype go nmap <leader>r :GoRun <cr><Esc>
  autocmd Filetype go nmap <leader>t <Plug>(go-test)
  autocmd Filetype go nmap <leader>c <Plug>(go-coverage-toggle)
  autocmd Filetype go nmap <leader>b :<C-u>call <SID>build_go_files()<cr>
augroup END

let g:go_fmt_command = "goimports"
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_fields = 1
let g:go_highlight_types = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand("%")
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

" vim:ft=vim

#+end_src
**** haskell
#+begin_src vimrc :tangle ./vim/rcfiles/haskell

augroup filetype_haskell
  " Clear old autocmds in group
  autocmd!
  autocmd FileType haskell nnoremap <leader>hr :Dispatch runhaskell %<tab><cr>
  autocmd FileType haskell nnoremap <leader>hb :Dispatch ghc %<tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** html
#+begin_src vimrc :tangle ./vim/rcfiles/html

augroup filetype_html
  " Clear old autocmds in group
  autocmd!
  " Install Emmet
  autocmd FileType html,css EmmetInstall
augroup END

" vim:ft=vim

#+end_src
**** javascript
#+begin_src vimrc :tangle ./vim/rcfiles/javascript
" au BufRead,BufNewFile *.json set filetype=json
augroup filetype_javascript
  " Clear old autocmds in group
  autocmd!
  " Set syntax javascript to coffee script files
  autocmd FileType javascript nnoremap <leader>r :Dispatch node %<cr>
  autocmd FileType javascript.jsx set ft=javascript
augroup END

" vim:ft=vim



#+end_src
**** json

#+begin_src vimrc :tangle ./vim/rcfiles/json
augroup filetype_json
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd Filetype json nmap <leader>p :w<cr> :PrettyJSON<cr> :w<cr>
augroup END

" Requires 'jq' (brew install jq)
function! s:PrettyJSON()
  %!jq .
  set filetype=json
endfunction
command! PrettyJSON :call <sid>PrettyJSON()
" vim:ft=vim

#+end_src
**** lua
#+begin_src vimrc :tangle ./vim/rcfiles/lua

augroup filetype_lua
  " Clear old autocmds in group
  autocmd!
  autocmd FileType lua nnoremap <leader>r :Dispatch lua %<Tab><cr>
augroup END
" vim:ft=vim
#+end_src
**** markdown
#+begin_src vimrc :tangle ./vim/rcfiles/markdown
augroup filetype_markdown_and_txt
  " Clear old autocmds in group
  autocmd!
  " By default, vim thinks .md is Modula-2.
  autocmd BufNewFile,BufReadPost *.md set filetype=markdown
  autocmd FileType pad-notes set filetype=markdown
  " Without this, vim breaks in the middle of words when wrapping
  autocmd FileType markdown setlocal nolist wrap lbr
  " Turn on spell-checking in markdown and text.
  autocmd BufRead,BufNewFile *.md,*.txt setlocal spell
  " Don't display whitespaces
  autocmd BufNewFile,BufRead *.txt setlocal nolist
augroup END

" vim: ft=vim
#+end_src
**** python
#+begin_src vimrc :tangle ./vim/rcfiles/python

let g:python_host_prog='/usr/bin/python'
let g:python3_host_prog='/usr/local/bin/python3'

augroup filetype_python
  " Clear old autocmds in group
  autocmd!
  autocmd BufNewFile,BufRead *.py setlocal ai sw=4 ts=4 sts=4 et fileformat=unix
  autocmd FileType python nnoremap <leader>py :Dispatch python3 %<Tab><cr>
  autocmd FileType python nnoremap <leader>pt :TestFile<cr>
  autocmd BufWritePre *.py :%s/\s\+$//e
augroup END
" vim:ft=vim

#+end_src
**** ruby
#+begin_src vimrc :tangle ./vim/rcfiles/ruby

let g:ruby_path = system('rvm current')
let ruby_operators = 1

augroup filetype_ruby
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd FileType rspec set filetype=ruby
  autocmd FileType ruby,eruby,yaml setlocal ai sw=2 sts=2 et
  autocmd FileType ruby,eruby,yaml setlocal path+=lib
  " Make ?s part of words
  autocmd FileType ruby,eruby,yaml setlocal iskeyword+=?
  autocmd FileType gitcommit setlocal spell textwidth=72
  " Run the current ruby file
  autocmd FileType ruby nnoremap <leader>r :Dispatch ruby %<cr>
  " Generage tags for ruby files
  autocmd FileType ruby nnoremap <Leader>rt :!ctags -R --languages=ruby --exclude=.git --exclude=log .<cr>
  " Remove trailing whitespace on save for ruby files.
  autocmd BufWritePre *.rb :%s/\s\+$//e
  autocmd BufRead,BufNewFile {Vagrantfile,Gemfile,Guardfile,Thorfile,Procfile,config.ru,*.rake,.pryrc} set filetype=ruby
  " Set .erb html files
  autocmd FileType eruby setlocal sw=2 sts=2 ts=2 " Two spaces per tab

  " Setting for vim-dispatch
  autocmd FileType ruby
        \ let b:start = executable('pry') ? 'pry -r "%:p"' : 'irb -r "%:p"' |
        \ if expand('%') =~# '_spec\.rb$' |
        \   let b:dispatch = 'rspec %' |
        \ elseif expand('%') =~# '_test\.rb$' |
        \   let b:dispatch = 'ruby -Ilib:test %' |
        \ elseif !exists('b:dispatch') |
        \   let b:dispatch = 'ruby -wc %' |
        \ endif

  " Clean comments
  autocmd FileType ruby nnoremap <leader>cc :g/#/d<cr>
  nnoremap <Leader>t :w<cr>:call RunTest('TestFile')<cr>
  nnoremap <Leader>s :call RunTest('TestNearest')<cr>
  nnoremap <Leader>a :call RunTest('TestSuite')<cr>
  nnoremap <Leader>l :call RunTest('TestLast')<cr>
  nnoremap <leader>or :tabe config/routes.rb<cr>
  nnoremap <leader>ol :tabe config/locales<cr>
augroup END

" Convert 1.8 hash syntax to 1.9 syntax
nnoremap <leader>19 :%s/:\([^ ]*\)\(\s*\)=>/\1:/gc<cr>
vnoremap <leader>19 :s/:\([^ ]*\)\(\s*\)=>/\1:/g<cr>
nnoremap <leader>18 :%s/\(\w\+\):\s/:\1 => /gc<cr>
vnoremap <leader>18 :s/\(\w\+\):\s/:\1 => /g<cr>

" vim:ft=vim
#+end_src
**** rust
#+begin_src vimrc :tangle ./vim/rcfiles/rust

augroup filetype_rust
  " Clear old autocmds in group
  autocmd!
  autocmd FileType rust nnoremap <leader>cr :Cargo run<cr>
  autocmd FileType rust nnoremap <leader>cb :Cargo build<cr>
augroup END
" vim:ft=vim
#+end_src
**** sql
#+begin_src vimrc :tangle ./vim/rcfiles/sql

augroup filetype_sql
  " Clear old autocmds in group
  autocmd!

  autocmd FileType sql call SqlFormatter()
augroup END

function SqlFormatter()
  set noai

  map ,pt :%!sqlformat --reindent --keywords upper --identifiers lower -<CR>
endfunction

" vim:ft=vim
#+end_src

*** refactoring
#+begin_src vimrc :tangle ./vim/rcfiles/refactoring
" Borrowed from Gary Bernhardt's vimrc
function! ExtractVariable()
  echohl String | let name = input("Variable name: ") | echohl None
  if name == '' | return | endif

  " Enter visual mode (input() takes us out of it)
  normal! gv

  " Replace selected text with the variable name
  exec "normal c" . name
  " Define the variable on the line above
  if &ft == "vim"
    exec "normal! Olet " . name . " = "
  elseif &ft == 'javascript'
    exec "normal! Ovar " . name . " = "
  else
    exec "normal! O" . name . " = "
  endif
  " Paste the original selected text to be the variable value
  normal! $p
  if &ft == 'javascript'
    normal! A;
  endif
endfunction
vnoremap <leader>ev :call ExtractVariable()<cr>

function! InlineVariable()
  if &filetype == 'javascript'
    s/\v^(\s+)var (.*);$/\1\2/
    nohl
  elseif &filetype == 'vim'
    s/\v^(\s+)let (.*)$/\1\2/
    nohl
  endif
  normal! ^*Ndf=x"vd$ddnviw"vp
endfunction
nnoremap <leader>ve :call InlineVariable()<cr>

" vim: ft=vim
#+end_src
** helpfiles
#+begin_src vimrc :tangle ./vim/rcfiles/helpfiles

au filetype help call HelpFileMode()

function! HelpFileMode()
  wincmd T " Maximze the help on open
  nnoremap <buffer> <tab> :call search('\|.\{-}\|', 'w')<cr>:noh<cr>2l
  nnoremap <buffer> <S-tab> F\|:call search('\|.\{-}\|', 'wb')<cr>:noh<cr>2l
  nnoremap <buffer> <cr> <c-]>
  nnoremap <buffer> <bs> <c-T>
  nnoremap <buffer> q :q<CR>
  setlocal nonumber
  setlocal nospell
endfunction

nnoremap <leader>rh :h local-additions<cr>

" vim:ft=vim

#+end_src

** mappings
#+begin_src vimrc :tangle ./vim/rcfiles/mappings

" Emacs-like mappings
nmap <C-x><C-s> :w<cr>
nmap <C-x><C-c> :x<cr>
nmap <C-s> /
nmap <C-x>b :FzfBuffers<cr>
nmap <C-c>pf :FzfFiles<cr>
nmap <C-x>1 :only<cr>
nmap <C-x>2 :split<cr>
nmap <C-x>3 :vsplit<cr>
nmap <C-x>0 :q<cr>

nnoremap <silent> H :call <SID>show_documentation()<cr>
nnoremap <silent> K :FzfRg <C-R><C-W><cr>

function! s:show_documentation()
  if (index(['vim', 'help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

" Opens help the word under the cursor
nnoremap <leader>h :exe 'help' expand('<cword>')<cr>

" select last paste in visual mode
nnoremap gp `[v`]

" Change vertically split to horizonally
nnoremap <leader>fh <C-w>t<C-w>K

" Change horizonally split to vertically
nnoremap <leader>fv <C-w>t<C-w>H

" Make Y yank to end of line (like D, or C)
nmap Y y$

" Insert a caller into Ruby code
nnoremap <leader>wtf oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc>

" Source vimrc
nnoremap <leader>sv :source ~/.vim/vimrc<cr>

" Toggle paste mode on and off
nnoremap <leader>pp :set paste<cr>o<esc>"*]p:set nopaste<cr>

nnoremap ; :

" Indent the whole file
nnoremap <Leader>i mmgg=G`m

" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
nnoremap <space>e :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <C-x><C-f> :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
nnoremap <space>s :split <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>v :vsplit <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>r :r <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>t :tabe <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
nnoremap <space>sav :sav <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>

" Use j/k to start, then scroll through autocomplete options
inoremap <expr> <C-j> ((pumvisible())?("\<C-n>"):("\<C-x><c-n>"))
inoremap <expr> <C-k> ((pumvisible())?("\<C-p>"):("\<C-x><c-k>"))

" Close the quickfix window
nnoremap <space><space> :ccl<cr>

" Increase and decrease numbers
nnoremap <C-b> <C-a>

" Let's be reasonable, shall we?
nnoremap k gk
nnoremap j gj

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f')<CR>

" When you press <leader>r you can search and replace the selected text
vnoremap <silent> <leader>r :call VisualSelection('replace')<CR>

" Disable arrows
for prefix in ['i', 'n', 'v']
  for key in ['<Up>', '<Down>', '<Left>', '<Right>']
    exe prefix . 'noremap ' . key . " <Nop>"
  endfor
endfor

" resize panes
nnoremap <silent> <Up> :call animate#window_delta_height(15)<cr>
nnoremap <silent> <Down> :call animate#window_delta_height(-15)<cr>
nnoremap <silent> <Left> :call animate#window_delta_width(30)<cr>
nnoremap <silent> <Right> :call animate#window_delta_width(-30)<cr>

" Scroll the viewport faster
nnoremap <C-e> 7<C-e>
nnoremap <C-y> 7<C-y>
vnoremap <C-e> 7<C-e>
vnoremap <C-y> 7<C-y>

" Disable mouse scroll wheel
nnoremap <ScrollWheelUp> <nop>
nnoremap <S-ScrollWheelUp> <nop>
nnoremap <C-ScrollWheelUp> <nop>
nnoremap <ScrollWheelDown> <nop>
nnoremap <S-ScrollWheelDown> <nop>
nnoremap <C-ScrollWheelDown> <nop>
nnoremap <ScrollWheelLeft> <nop>
nnoremap <S-ScrollWheelLeft> <nop>
nnoremap <C-ScrollWheelLeft> <nop>
nnoremap <ScrollWheelRight> <nop>
nnoremap <S-ScrollWheelRight> <nop>
nnoremap <C-ScrollWheelRight> <nop>

" Open Gemfile
nnoremap <leader>og :e Gemfile<cr>

" Jump to start and end of line using the home row keys
nmap 0 ^

" Tab/shift-tab to indent/outdent in visual mode.
vnoremap <Tab> >gv
vnoremap <S-Tab> <gv

" Quickly browse to any tag/symbol in the project
nmap <leader>ot :tag<space>

" Save file as sudo
cmap w!! w !sudo tee % >/dev/null

" Move split to tab
noremap <leader>mt <c-w><s-t>

" Map to increment and decrement
nnoremap + <C-a>
nnoremap - <C-x>
xnoremap + g<C-a>
xnoremap - g<C-x>

" Open Lazygit
nnoremap <leader>tlg :call OpenHTerm('lazygit', 0.8)<cr>
" Open Lazydocker
nnoremap <leader>tld :call OpenHTerm('lazydocker', 0.8)<cr>

" Correct previous misspelled word ( Don't forgot to set spell )
nnoremap <space>sp mm[s1z=`m

"vim:ft=vim
#+end_src

** remote yank
#+begin_src vimrc :tangle ./vim/rcfiles/remote-yank

nnoremap <leader>li :call RemoteYank('i')<cr>
nnoremap <leader>la :call RemoteYank('a')<cr>
nnoremap <leader>lr :call RemoteYank('r')<cr>

function! RemoteYank(dir)
  if &relativenumber
    echom "setting number"
    let was_relative = 1
    set number
    redraw!
  endif

  echohl String | let line = input("Remote link to yank: ") | echohl None
  if line == '' | return | endif

  execute line.'yank a'
  if a:dir == 'i'
    normal "aP
  elseif a:dir == 'a'
    normal "ap
  else
    normal V"ap
  endif

  if was_relative
    set relativenumber
  endif
endfunction

" vim:ft=vim
#+end_src

** search
#+begin_src vimrc :tangle ./vim/rcfiles/search

" Searching stuff
set hlsearch                    " highlight searches, map below to clear
set incsearch                   " do incremental searching
set ignorecase                  " Case insensitive...
set smartcase                   " ...except if you use UCase

nnoremap <silent><leader><space> :nohl<cr>

" quick searching of vimrc files
function! s:VimrcSearch()
  echohl String | let text = input("Text to search: ") | echohl None
  if text == '' | return | endif
  execute "Rg ". text ." ~/.dotfiles/vim/rcfiles/* ~/.dotfiles/vim/rcplugins/*"
endfunction
command! VimrcSearch call <sid>VimrcSearch()
nnoremap <leader>sr :VimrcSearch<cr>

" Mappings for quick search & replace. Global set to default
" Do a / search first, then leave pattern empty in :s// to use previous
nnoremap <Leader>sub :%s///g<left><left>
vnoremap <Leader>sub :s///g<left><left>
nnoremap <leader>wub :%s//<C-r><C-w>/g<cr>

" Search for selected text, forwards or backwards.
" http://vim.wikia.com/wiki/Search_for_visually_selected_text
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

nnoremap Q @q
vnoremap Q :normal Q<cr>

" vim:ft=vim
#+end_src

** statusline
For general info on statusline, start with the :h, then see [[http://got-ravings.blogspot.com/2008/08/vim-pr0n-making-statuslines-that-own.html][this link]]
NOTE: NSFW, but very good overview of statusling configuration

#+begin_src vimrc :tangle ./vim/rcfiles/statusline

"Use this to prevent some settings from reloading
let g:vimrc_loaded = 1

set laststatus=2 " Always show the statusline

"define 3 custom highlight groups
hi User1 ctermbg=lightgray ctermfg=yellow guifg=orange guibg=#444444 cterm=bold gui=bold
hi User2 ctermbg=lightgray ctermfg=red guifg=#dc143c guibg=#444444 gui=none
hi User3 ctermbg=lightgray ctermfg=red guifg=#ffff00 guibg=#444444 gui=bold

set statusline= " Clear the statusline for vimrc reloads

set stl=%*                        " Normal statusline highlight
set stl^=%{coc#status()}%{get(b:,'coc_current_function','')} " coc status line
set stl+=%{fugitive#statusline()} " Current branch
set stl+=%{InsertSpace()}         " Put a leading space in

set stl+=%1*                      " Red highlight
set stl+=%{HasPaste()}            " Red show paste
set stl+=%*                       " Return to normal stl hilight

set stl+=%-40f\                   " Filename

set stl+=%2*                      " Red highlight
set stl+=%m                       " Modified flag

set stl+=%*                       " Return to normal stl hilight
set stl+=%r                       " Readonly flag
set stl+=%h                       " Help file flag

set stl+=%*                       " Set to 3rd highlight
set stl+=\ %y                     " Filetype

set stl+=%=                       " Right align from here on
set statusline+=%{SlSpace()}      " Vim-space plugin current setting
set stl+=\ \ Col:%c               " Column number
set stl+=\ \ Line:%l/%L           " Line # / total lines
set stl+=\ \ %P%{InsertSpace()}   " Single space buffer

" set stl+=%2*                    " Yello highlight
" set stl+=%*                     " Return to normal stl hilight

function! SlSpace()
  if exists("*GetSpaceMovement")
    return "[" . GetSpaceMovement() . "]"
  else
    return ""
  endif
endfunc

function! InsertSpace()
  " For adding trailing spaces onto statusline
  return ' '
endfunction

function! HasPaste()
  if &paste
    return '[PASTE]'
  else
    return ''
  endif
endfunction

function! CurDir()
  let curdir = substitute(getcwd(), '/Users/pablobfonseca/', "~/", "g")
  return curdir
endfunction

" vim:ft=vim
#+end_src

** tags
#+begin_src vimrc :tangle ./vim/rcfiles/tags

set tags^=./.git/tags

augroup tags_stuff
  " Clear old autocmds in group
  autocmd FileType * call EnableTagNavMaps()
augroup END

function! EnableTagNavMaps()
  if s:BufferIsTagNavigable()
    nmap <buffer> <bs> <c-t>
  endif
endfunction

let s:navigable_filetypes = ['vim', 'ruby', 'javascript', 'sh']

function! s:BufferIsTagNavigable()
  let is_navigable_filetype = index(s:navigable_filetypes, &filetype) != -1
  let is_normal_buffer = &buftype !=? 'nofile'
  return is_navigable_filetype && is_normal_buffer
endfunction

" Generate ctags
nnoremap <Leader>rt :!ctags --tag-relative --extras=+f -Rf .git/tags --languages=-javascript,sql<CR>

function! s:RebuildTagsFile()
  !ctags -R --exclude=coverage --exclude=files --exclude=public --exclude=log --exclude=tmp --exclude=vendor *
endfunction
command! -nargs=0 RebuildTagsFile call s:RebuildTagsFile()

" vim:ft=vim
#+end_src

** templates
#+begin_src vimrc :tangle ./vim/rcfiles/templates

if has("autocmd")
  augroup templates
    autocmd!
    autocmd BufNewFile *.sh 0r ~/.vim/templates/skeleton.sh
  augroup END
endif
" vim: ft=vim
#+end_src

** terminal
#+begin_src vimrc :tangle ./vim/rcfiles/terminal

augroup terminal
  " Clear old autocmds in group
  autocmd!

  if has('nvim')
    autocmd BufEnter * if &buftype == 'terminal' | :startinsert | endif

    " Quit term buffer with Esc
    tnoremap <silent> <Esc> <C-\><C-n><cr>

    " use alt+hjkl to move between split/vsplit panels
    tnoremap <c-h> <C-\><C-n><C-w>h
    tnoremap <c-j> <C-\><C-n><C-w>j
    tnoremap <c-k> <C-\><C-n><C-w>k
    tnoremap <c-l> <C-\><C-n><C-w>l
    function! OpenTerminal()
      split | terminal
      " split term:///usr/local/bin/fish
      resize 10
    endfunction
  " Open Terminal on Ctrl+n
    nnoremap <C-x>n :call OpenTerminal()<cr>
  endif
augroup END

" vim:ft=vim
#+end_src

** vim
#+begin_src vimrc :tangle ./vim/rcfiles/vim

augroup vim_stuff
  " Clear old autocmds in group
  autocmd!
  " automatically rebalance windows on vim resize
  autocmd VimResized * :wincmd =
  " Execute the vim current vim command line
  autocmd Filetype vim nnoremap <leader>x :execute getline(".")<cr>

  " Wrap the quickfix window
  autocmd FileType qf setlocal wrap linebreak
  autocmd BufWritePre * :call s:MkNonExDir(expand('<afile>'), +expand('<abuf>'))
  autocmd BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" Functions

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
nnoremap <Leader>rr :call RenameFile()<cr>

function! CmdLine(str)
  exe "menu Foo.Bar :" . a:str
  emenu Foo.Bar
  unmenu Foo
endfunction

function! VisualSelection(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'gv'
    call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

function! s:MkNonExDir(file, buf)
  if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
    let dir=fnamemodify(a:file, ':h')
    if !isdirectory(dir)
      call mkdir(dir, 'p')
    endif
  endif
endfunction

function! AlignSection(regex) range
  let extra = 1
  let sep = empty(a:regex) ? '=' : a:regex
  let maxpos = 0
  let section = getline(a:firstline, a:lastline)
  for line in section
    let pos = match(line, ' *'.sep)
    if maxpos < pos
      let maxpos = pos
    endif
  endfor
  call map(section, 'AlignLine(v:val, sep, maxpos, extra)')
  call setline(a:firstline, section)
endfunction
command! -nargs=? -range Align <line1>,<line2>call AlignSection('<args>')
vnoremap <silent> <Leader>al :Align<CR>

function! AlignLine(line, sep, maxpos, extra)
  let m = matchlist(a:line, '\(.\{-}\) \{-}\('.a:sep.'.*\)')
  if empty(m)
    return a:line
  endif
  let spaces = repeat(' ', a:maxpos - strlen(m[1]) + a:extra)
  return m[1] . spaces . m[2]
endfunction

" TODO: Create a function to search gems right from vim
function! SearchForCallSitesCursor()
  let searchTerm = expand("<cword>")
  call SearchForCallSites(searchTerm)
endfunction

" Search for call sites for term (excluding its definition) and
" load into the quickfix list.
function! SearchForCallSites(term)
  cexpr system('ag ' . shellescape(a:term) . '\| grep -v def')
endfunction

" vim:ft=vim
#+end_src

** visual
#+begin_src vimrc :tangle ./vim/rcfiles/visual

colorscheme vendetta

set visualbell

" Easy access to maximizing
nnoremap <C-_> <C-w>_

set splitbelow
set splitright

" Colors
set t_Co=256
hi Search guifg=#000000 guibg=#8dabcd guisp=#8dabcd gui=NONE ctermfg=NONE ctermbg=110 cterm=NONE
hi WarningMsg guifg=#bd4848 guibg=#f9f8ff guisp=#f9f8ff gui=bold ctermfg=131 ctermbg=15 cterm=bold
hi ErrorMsg guifg=#bd5353 guibg=NONE guisp=NONE gui=NONE ctermfg=131 ctermbg=NONE cterm=NONE

" Make it more obvious which paren I'm on
hi MatchParen cterm=none ctermbg=black ctermfg=yellow

hi! link Search CursorLine
hi! link SpellBad ErrorMsg
hi! link SpellCap ErrorMsg
hi! link Error ErrorMsg

nnoremap <leader>! :redraw!<cr>

" zoom a vim pane, <C-w>= to re-balance
nnoremap <leader>- :wincmd _<cr>:wincmd \|<cr>
nnoremap <leader>= :wincmd =<cr>

" vim:ft=vim
#+end_src

** zsh
#+begin_src vimrc :tangle ./vim/rcfiles/zsh

augroup filetype_zsh
  " Clear old autocmds in group
  autocmd!
  " set shell syntax for zsh files
  autocmd FileType zsh set syntax=sh
  autocmd BufRead,BufNewFile *.zsh-theme set filetype=zsh
augroup END

command! ReformatCurlRequest silent %s/\s\(-.\{-}\)\s/
 \1 /g

" vim:ft=vim
#+end_src

